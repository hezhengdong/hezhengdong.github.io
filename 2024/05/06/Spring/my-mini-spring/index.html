<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mini-spring原理解析 | Easton Voyager</title><meta name="author" content="Easton Voyager"><meta name="copyright" content="Easton Voyager"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="导言在Spring框架中，BeanFactory 是最基本的容器，负责依赖注入和 Bean 的生命周期管理； ApplicationContext是建立在这个基础之上的更加丰富和完善的容器环境，不仅包含了 BeanFactory的所有功能，还扩展了很多企业级支持； 两个主要的后处理器 BeanFactoryPostProcessor和 BeanPostProcessor构成了Spring功能扩展的">
<meta property="og:type" content="article">
<meta property="og:title" content="mini-spring原理解析">
<meta property="og:url" content="http://example.com/2024/05/06/Spring/my-mini-spring/index.html">
<meta property="og:site_name" content="Easton Voyager">
<meta property="og:description" content="导言在Spring框架中，BeanFactory 是最基本的容器，负责依赖注入和 Bean 的生命周期管理； ApplicationContext是建立在这个基础之上的更加丰富和完善的容器环境，不仅包含了 BeanFactory的所有功能，还扩展了很多企业级支持； 两个主要的后处理器 BeanFactoryPostProcessor和 BeanPostProcessor构成了Spring功能扩展的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2024-05-06T14:52:00.000Z">
<meta property="article:modified_time" content="2024-05-06T14:58:23.045Z">
<meta property="article:author" content="Easton Voyager">
<meta property="article:tag" content="keywords关键词,Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/06/Spring/my-mini-spring/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mini-spring原理解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-06 22:58:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Easton Voyager"><span class="site-name">Easton Voyager</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mini-spring原理解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T14:52:00.000Z" title="发表于 2024-05-06 22:52:00">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-06T14:58:23.045Z" title="更新于 2024-05-06 22:58:23">2024-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SSM/">SSM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mini-spring原理解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>在Spring框架中，<code>BeanFactory</code> 是最基本的容器，负责依赖注入和 Bean 的生命周期管理；</p>
<p><code>ApplicationContext</code>是建立在这个基础之上的更加丰富和完善的容器环境，不仅包含了 <code>BeanFactory</code>的所有功能，还扩展了很多企业级支持；</p>
<p>两个主要的后处理器 <code>BeanFactoryPostProcessor</code>和 <code>BeanPostProcessor</code>构成了Spring功能扩展的主要分支，通过介入Bean的生命周期和容器的配置处理，进一步增强了Spring容器的灵活性和功能性。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>对于源码的阅读，每一个类就像一个螺丝钉，一定要大致了解每个类的用处，然后再去理解源码的执行流程。</p>
<p>一定要重视单元测试，debug打好断点一步步跟着走一遍，当然要先理清核心类的构建思路。</p>
<blockquote>
<p>悟从疑得，乐自苦生。</p>
</blockquote>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>主要负责单个bean的构建</p>
<ol>
<li><strong>bean实例化策略</strong> <code>InstantiationStrategy</code><ul>
<li>构造函数实例化<ul>
<li><a href="#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5">无参构造</a></li>
<li>有参构造</li>
</ul>
</li>
<li>工厂方式实例化<ul>
<li>静态工厂方式</li>
<li>动态工厂方式</li>
<li><a href="#FactoryBean">FactoryBean</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
<li><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载</a></li>
<li>[占位符解析](#3. 占位符解析)（这个跟 <code>BeanFactoryPostProcessor</code>有关）</li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95">初始化和销毁方法</a><ul>
<li>三种方式：xml文件定义属性、实现接口，加注解（第三种基于 <code>BeanPostProcessor</code>）</li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">循环依赖</a>（<code>DefaultSingletonBeanRegister</code>单例注册表）</li>
</ol>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><ol>
<li><p><strong>资源管理体系的集成</strong>（资源的识别、加载、解析）</p>
<ul>
<li><p><a href="#%E8%B5%84%E6%BA%90%E5%92%8C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8">资源和资源加载器</a>（<code>ResourceLoader</code>）</p>
</li>
<li><p>资源的处理和解析（对已加载资源的进一步处理和解析）</p>
<ul>
<li><a href="#XML%E8%A7%A3%E6%9E%90">XML解析</a></li>
<li>[包扫描](#1. 包扫描、@Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor)</li>
<li>[注解解析](#1. 包扫描、@Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor)（实例化）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自动生命周期管理</strong></p>
<ul>
<li>[自动启动](#2. refresh 初始化和刷新 Spring 容器)（在启动时自动创建和配置所有的bean，即时实例化）</li>
<li>集成的两个后处理器提供更加细致灵活的管理和扩展</li>
</ul>
</li>
<li><p>[上下文感知](#2. ApplicationContextAware)</p>
</li>
<li><p><strong>额外企业级支持</strong></p>
<ul>
<li><a href="#%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8">事件和监听机制</a></li>
<li>国际化支持</li>
<li>环境抽象</li>
</ul>
</li>
</ol>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><ol>
<li><p>[占位符解析](#3. 占位符解析)</p>
<p><code>PropertyPlaceholderConfigurer</code></p>
</li>
</ol>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><ol>
<li><p>[注解方式属性注入](#2. 实例化bean，@Value注解扫描，为bean注入属性)</p>
<p><code>AutowiredAnnotationBeanPostProcessor</code></p>
</li>
<li><p><strong>注解方式生命周期回调</strong></p>
<p><code>CommonAnnotationBeanPostProcessor</code></p>
<p>如 <code>@PostConstruct</code>、<code>@PreDestroy</code></p>
</li>
<li><p>[上下文感知](#2. ApplicationContextAware)</p>
<p><code>ApplicationContextAwareProcessor</code></p>
</li>
<li><p><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-JDK">AOP动态代理</a></p>
<p><code>DefaultAdvisorAutoProxyCreator</code></p>
</li>
</ol>
<blockquote>
<p>生命周期回调：Spring 允许Bean在关键生命周期点执行自定义的逻辑，如初始化后或销毁前。</p>
</blockquote>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="1-接口的多态性"><a href="#1-接口的多态性" class="headerlink" title="1. 接口的多态性"></a>1. 接口的多态性</h2><blockquote>
<p>问题：Java中，一个接口，两个实现了接口的类，这两个类不相关，一个类实现了接口中的方法，一个类调用了接口中的方法，为什么调用接口方法的类能够调用到另一个类中对该接口的实现?</p>
</blockquote>
<p>在Java中，多态允许一个接口引用变量来引用多种具体实现的对象，这意味着一个接口的引用可以指向任何实现了该接口的类的对象。这种特性使得程序可以在不改变接口的前提下，使用由不同类创建的对象，从而实现代码的灵活性和复用性。</p>
<h2 id="2-接口做识别功能"><a href="#2-接口做识别功能" class="headerlink" title="2. 接口做识别功能"></a>2. 接口做识别功能</h2><p>Spring框架中经常使用接口做识别功能</p>
<p>例如：Spring容器通过自动检测实现了特定接口的Bean，然后添加额外逻辑。</p>
<p>当然，开发者也可以借助此功能自定义额外功能扩展</p>
<p>例如：如果开发者想使用 <code>BeanPostProcessor</code>做额外功能的扩展，可以先做好逻辑，然后重写一个接口继承自 <code>BeanPostProcessor</code>，实现该接口的独有方法，然后以此为识别条件插入生命周期当中。</p>
<h1 id="Spring-软件设计原则"><a href="#Spring-软件设计原则" class="headerlink" title="Spring-软件设计原则"></a>Spring-软件设计原则</h1><h2 id="1-接口隔离原则"><a href="#1-接口隔离原则" class="headerlink" title="1. 接口隔离原则"></a>1. 接口隔离原则</h2><p>Spring将接口 按功能 划分的尽可能小而精简，避免了不必要的依赖和接口的臃肿。</p>
<h2 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h2><p>Spring框架将应用程序拆分为小的可重用组件，并通过对象组合的方式将这些组件组合在一起构建应用程序。通过<strong>组件化设计</strong>，使得系统更加模块化、可维护和可扩展。</p>
<h1 id="Spring-设计模式"><a href="#Spring-设计模式" class="headerlink" title="Spring-设计模式"></a>Spring-设计模式</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h2><p><code>BeanFactory</code>和 <code>ApplicationContext</code>使用工厂模式创建对象，不通过构造函数创建，而将职责移交给内部复杂的IoC容器，大大增强了Spring的模块性、扩展性与灵活性。</p>
<p>二者还将bean的创建细节封装在容器内部，大大简化了bean的配置与管理，使开发者更专注于业务逻辑的实现。</p>
<h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><p>每个单例bean只被创建一次，在后续重用。</p>
<h2 id="3-模板方法模式"><a href="#3-模板方法模式" class="headerlink" title="3. 模板方法模式"></a>3. 模板方法模式</h2><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<p>在Bean工厂中模板方法模式运用的非常彻底，调用者直接调用父类的方法，父类方法的具体实现延伸到了子类中来实现。</p>
<h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h2><p>将一个复杂对象的构建拆解开来，使用指挥者类来调用方法创建对象。<code>doCreateBean()</code>和 <code>refresh()</code>方法体现了分步创建复杂对象的思想，将复杂对象的构建拆解开来，通过不同的子过程来”建造”一个完整的Bean对象，用指挥者指挥建造者的方法来调用方法，清晰明了。</p>
<h2 id="5-外观模式"><a href="#5-外观模式" class="headerlink" title="5. 外观模式"></a>5. 外观模式</h2><p>最典型的就是 <code>BeanFactory</code>的 <code>getBean()</code>，封装内部的复杂逻辑，对外只暴露简单的接口。</p>
<p>另一个例子是 <code>ApplicationContext</code>，它集成了 <code>BeanFactory</code>功能并提供更高级的功能（如事件发布、国际化支持等），同样为复杂的底层实现提供了简单的调用接口。</p>
<h2 id="6-策略模式"><a href="#6-策略模式" class="headerlink" title="6. 策略模式"></a>6. 策略模式</h2><p>Spring的实例化策略、资源加载器、AOP代理、类型转换等都可以根据传入参数的不同在运行时决定使用的策略，实现策略的切换。</p>
<p>这种模式解耦了算法的选择和实施的过程，使得算法可以独立于使用它们的客户端变化。策略模式的应用帮助框架提高了灵活性和可扩展性，使得开发者可以根据具体的需求轻松地切换和配置不同的行为。</p>
<h2 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7. 适配器模式"></a>7. 适配器模式</h2><p>[bean的销毁方法](#3. 适配器模式的应用)：<code>DisposableBeanAdapter</code>将不同的销毁机制适配到一个统一的接口</p>
<p>[注解的解析](#0.3 适配器模式*)&amp;[类型转换](#2.1 适配器模式)：都通过内部类的方式将不同接口的子实现类结合到一起</p>
<h2 id="8-观察者模式"><a href="#8-观察者模式" class="headerlink" title="8. 观察者模式"></a>8. 观察者模式</h2><p>[事件和监听机制](#1. 观察者模式)</p>
<h2 id="9-代理模式"><a href="#9-代理模式" class="headerlink" title="9. 代理模式"></a>9. 代理模式</h2><p>AOP动态代理</p>
<h2 id="10-责任链模式"><a href="#10-责任链模式" class="headerlink" title="10. 责任链模式"></a>10. 责任链模式</h2><p>[拦截器链](#7. 责任链模式)</p>
<h1 id="最简单的bean容器"><a href="#最简单的bean容器" class="headerlink" title="最简单的bean容器"></a>最简单的bean容器</h1><p><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/image-20240506144409831.png" alt="image-20240506144409831"></p>
<p><code>DefaultListableBeanFactory</code> 是 Spring IoC 容器的默认实现之一，具有注册和管理 Bean 定义、创建和管理 Bean 实例、管理 Bean 生命周期等功能。</p>
<p><code>BeanFactory</code>的子实现接口：</p>
<ul>
<li><code>HierarchicalBeanFactory</code>用于表示具有层次结构的 <code>BeanFactory</code></li>
<li><code>ConfigurableBeanFactory</code>用于表示可配置的 <code>BeanFactory</code></li>
<li><code>AutowireCapableBeanFactory</code> 用于表示可自动装配的 <code>BeanFactory</code>。可以实现对 Bean 的自动装配，包括按名称、按类型、构造器自动装配等。</li>
<li><code>ListableBeanFactory</code>用于表示可列举的 <code>BeanFactory</code>。提供了对 Bean 列表进行操作的方法，而不仅仅是获取单个 Bean 实例。</li>
<li><code>ConfigurableListableBeanFactory</code>继承自以上三个接口，可以实现对 <code>BeanFactory</code>配置和 Bean 列表操作的同时，还支持对 Bean 的自动装配。</li>
</ul>
<h1 id="Bean实例化策略"><a href="#Bean实例化策略" class="headerlink" title="Bean实例化策略"></a>Bean实例化策略</h1><p><code>InstantiationStrategy</code></p>
<p>使用了策略模式</p>
<p><code>InstantiationStrategy</code>接口</p>
<p>用于定义创建 Bean 实例的策略，例如通过调用构造函数、通过工厂方法、或者通过其他方式创建。</p>
<p><code>SimpleInstantiationStrategy</code></p>
<p>Spring 框架中的一个简单的 Bean 实例化策略，用于通过调用类的无参构造方法来创建 Bean 实例。它是默认的 Bean 实例化策略之一，在大多数情况下都可以满足需求。</p>
<p><code>CglibSubclassingInstantiationStrategy</code></p>
<p>Spring 框架中用于基于 CGLIB 进行子类化的 Bean 实例化策略，用于创建 Bean 实例的代理对象。</p>
<p>目前只支持无参构造实例化。</p>
<h1 id="注入属性"><a href="#注入属性" class="headerlink" title="注入属性"></a>注入属性</h1><p>分为两类</p>
<ul>
<li>为Bean注入普通属性</li>
<li>为Bean注入Bean</li>
</ul>
<p><code>BeanReference</code></p>
<p>Spring 框架中用于表示对其他 Bean 的引用的类，它提供了延迟解析的功能，并支持循环依赖的处理。</p>
<p>在 XML 配置文件中，可以使用 <code>&lt;ref&gt;</code> 元素来声明对其他 bean 的引用，而在 Spring 的内部处理过程中，这些引用将会被解析为 <code>BeanReference</code> 对象。</p>
<h1 id="资源和资源加载器"><a href="#资源和资源加载器" class="headerlink" title="资源和资源加载器"></a>资源和资源加载器</h1><p>这个也算是一个策略模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">direction BT</span><br><span class="line">class ClassPathResource</span><br><span class="line">class DefaultResourceLoader</span><br><span class="line">class FileSystemResource</span><br><span class="line">class Resource &#123;</span><br><span class="line">&lt;&lt;Interface&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class ResourceLoader &#123;</span><br><span class="line">&lt;&lt;Interface&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class UrlResource</span><br><span class="line"></span><br><span class="line">ClassPathResource  ..&gt;  Resource </span><br><span class="line">DefaultResourceLoader  ..&gt;  ResourceLoader </span><br><span class="line">FileSystemResource  ..&gt;  Resource </span><br><span class="line">UrlResource  ..&gt;  Resource </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Resource</code> 接口是 Spring 框架中用于表示外部资源的抽象接口，它提供了统一的资源访问接口，并支持不同类型的资源以及与其他 Spring 模块的集成。</p>
<ul>
<li><code>ClassPathResource</code> 是 Spring 框架中用于表示类路径下资源的类。</li>
<li><code>FileSystemResource</code> 是 Spring 框架中用于表示文件系统中资源的类。</li>
<li><code>UrlResource</code> 是 Spring 框架中用于表示 URL 资源的类。</li>
</ul>
<p>这三个类可以使得应用程序能够方便地访问类路径下、文件系统中、各种类型的URL的资源，而不需要关心资源的具体位置和加载方式。这样可以增加应用程序的灵活性和可移植性，同时也使得代码更加清晰和易于维护。（根据IO流获取）</p>
<p><code>ResourceLoader</code> 是 Spring 框架中的一个接口，用于加载资源。通过它可以方便地获取各种类型的资源对象，从而实现资源的统一管理和使用。</p>
<p><code>DefaultResourceLoader</code> 是 Spring 框架中资源加载的默认实现，提供了一种简单方便的方式来加载资源，支持多种资源类型，具有良好的扩展性和定制性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceAndResourceLoaderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResourceLoader</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">DefaultResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//加载classpath下的资源</span></span><br><span class="line">		<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;classpath:hello.txt&quot;</span>);</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> resource.getInputStream();</span><br><span class="line">		<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> IoUtil.readUtf8(inputStream);</span><br><span class="line">		System.out.println(content);</span><br><span class="line">		assertThat(content).isEqualTo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//加载文件系统资源</span></span><br><span class="line">		resource = resourceLoader.getResource(<span class="string">&quot;src/test/resources/hello.txt&quot;</span>);</span><br><span class="line">		assertThat(resource <span class="keyword">instanceof</span> FileSystemResource).isTrue();</span><br><span class="line">		inputStream = resource.getInputStream();</span><br><span class="line">		content = IoUtil.readUtf8(inputStream);</span><br><span class="line">		System.out.println(content);</span><br><span class="line">		assertThat(content).isEqualTo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//加载url资源</span></span><br><span class="line">		resource = resourceLoader.getResource(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">		assertThat(resource <span class="keyword">instanceof</span> UrlResource).isTrue();</span><br><span class="line">		inputStream = resource.getInputStream();</span><br><span class="line">		content = IoUtil.readUtf8(inputStream);</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<ol>
<li>使用resourceLoader.getResource根据类型返回resuorce接口实现类对象</li>
<li>调用resource.getInputStream获得字节输入流，然后解析</li>
</ol>
<h1 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h1><p><code>BeanDefinitionReader</code> 是 Spring 框架中用于读取和解析 Bean 定义信息的接口，它将外部资源中的配置信息解析为内部数据结构，并将其注册到 IoC 容器中，以便后续的 Bean 实例化和管理。</p>
<p><code>AbstractBeanDefinitionReader</code> 是 Spring 框架中用于读取和解析 Bean 定义信息的抽象基类，提供了一些通用的方法和属性，用于封装读取外部资源和解析 Bean 定义的通用功能，并定义了一些扩展点，支持不同格式配置文件的解析和加载。</p>
<p><strong>模板方法和实际执行方法</strong>，例如 <code>loadBeanDefinitions</code>和 <code>doLoadBeanDefinitions</code>，还有子类和父类方法的配合</p>
<h1 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h1><p>两个后处理器何时执行？怎么执行？</p>
<p>首先，二者都要被注入到Spring容器当中</p>
<h2 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1. BeanFactoryPostProcessor"></a>1. BeanFactoryPostProcessor</h2><p>bean工厂后处理器使用 <code>getBeanOfType()</code>获得工厂后处理器Bean，然后调用方法for循环全都执行了</p>
<h2 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. BeanPostProcessor</h2><p>bean后处理器也是先被注入，但是要等实例化bean时，在 <code>doCreateBean()</code>方法中被插入、调用</p>
<h1 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h1><p>Application</p>
<p>变动：创建了一个context包</p>
<h2 id="1-继承体系"><a href="#1-继承体系" class="headerlink" title="1. 继承体系"></a>1. 继承体系</h2><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/image-20240422163717033.png" alt="image-20240422163717033" style="zoom:50%;" />

<h2 id="2-refresh和getBean"><a href="#2-refresh和getBean" class="headerlink" title="2. refresh和getBean"></a>2. refresh和getBean</h2><p><code>refresh()</code> 方法用于初始化和刷新 Spring 容器，而 <code>getBean()</code> 方法用于从容器中获取 Bean 实例。<code>&lt;span style=&quot;color:red&quot;&gt;</code>在实际应用中，通常是先调用 <code>refresh()</code> 方法初始化容器，然后再通过 <code>getBean()</code> 方法获取所需的 Bean 实例来进行业务操作。</p>
<p>例如：</p>
<p>这一步执行 <code>refresh()</code>方法（内部可能会提前执行一些 <code>getBean()</code>方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:auto-proxy.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一步才执行对应的 <code>getBean()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WorldService</span> <span class="variable">worldService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;worldService&quot;</span>, WorldService.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-getBean-从容器中获取Bean实例"><a href="#2-1-getBean-从容器中获取Bean实例" class="headerlink" title="2.1 getBean 从容器中获取Bean实例"></a>2.1 getBean 从容器中获取Bean实例</h3><ul>
<li><p>DefaultListableBeanFactory的正常加载</p>
<p>当创建容器解析文件后，Bean只是被创建和初始化，尚未被实例化。</p>
<p>当用户传递名称确定要获取的bean时，才会对Bean进行实例化。</p>
</li>
<li><p>具体步骤：见上面</p>
</li>
<li><pre><code class="java">@Override
public Object getBean(String name) throws BeansException &#123;
    Object bean = getSingleton(name);
    if (bean != null) &#123;
        return bean;
    &#125;
    BeanDefinition beanDefinition = getBeanDefinition(name);
    return createBean(name, beanDefinition);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  先进行判断单例池中是否存在要查找的对象，若没有，那就根据BeanDefinition实时创建一个，并添加到单例池中。</span><br><span class="line"></span><br><span class="line">### 2.2 refresh 初始化和刷新 Spring 容器</span><br><span class="line"></span><br><span class="line">* ClassPathXmlApplicationContext的提前加载</span><br><span class="line"></span><br><span class="line">  通过调用 `refresh()` 方法，会执行 `beanFactory.preInstantiateSingletons()` 来提前实例化所有的单例 Bean，以提高应用程序的启动性能和响应速度。</span><br><span class="line">* 具体步骤：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Override</span><br><span class="line">  public void refresh() throws BeansException &#123;</span><br><span class="line">      /*</span><br><span class="line">      1. 刷新或创建一个完整的Bean工厂对象</span><br><span class="line">      这一个方法相当于DefaultListableBeanFactory的三步</span><br><span class="line">          // 1. 先创建一个DefaultListableBeanFactory对象作为容器</span><br><span class="line">          DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br><span class="line">          // 2. 创建读取器并将容器传给它</span><br><span class="line">          XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">          // 3. 读取器从xml文件中读取bean定义，并将其加载到容器中</span><br><span class="line">          beanDefinitionReader.loadBeanDefinitions(&quot;classpath:spring.xml&quot;);</span><br><span class="line">       */</span><br><span class="line">      refreshBeanFactory();</span><br><span class="line">      // 2. 获得刚刚刷新或创建的Bean工厂实例</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">      // 3. 在Bean实例化之前，执行BeanFactoryPostProcessor</span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      // 4. BeanPostProcessor需要提前在其他bean实例化之前注册</span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      // 5. 提前实例化单例Bean，提高应用程序的启动性能和响应速度</span><br><span class="line">      beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="3-目前认为的重点"><a href="#3-目前认为的重点" class="headerlink" title="3. 目前认为的重点"></a>3. 目前认为的重点</h2><ol>
<li>设置容器的地方要清楚，通常是 <code>AbstractXXX</code>抽象类</li>
<li><code>getBean()</code>和 <code>refresh()</code>的执行流程要清楚（这个明白后基本也就明白 <code>ApplicationContext</code>和 <code>BeanFactory</code>的区别了）</li>
<li>提前加载 <code>refresh</code>、正常加载 <code>getBean</code>、延时加载</li>
</ol>
<h1 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h1><p>（将初始化和销毁方法添加到doCreate生命周期中）</p>
<h2 id="1-用到的类"><a href="#1-用到的类" class="headerlink" title="1. 用到的类"></a>1. 用到的类</h2><ol>
<li><p><code>BeanDefinition</code>中增加了 <code>initMethodName</code>和 <code>destroyMethodName</code></p>
</li>
<li><p><code>XmlBeanDefinitionReader</code>增加了对 <code>init-method</code>和 <code>destroy-method</code>属性的读取</p>
</li>
<li><p>增加了 <code>DisposableBean</code>接口和 <code>InitializingBean</code>接口</p>
</li>
<li><p><code>ConfigurableBeanFactory</code>接口增加了 <code>destroySingletons</code>销毁单例Bean方法</p>
</li>
<li><p><code>DefaultSingletonBeanRegistry</code>增加了存储可被销毁Bean的容器，增加并实现了注册和销毁Bean的方法</p>
</li>
<li><p>新增了<code>&lt;span style=&quot;color:red&quot;&gt;DisposableBeanAdapter</code>类，实现了 <code>DisposableBean</code>接口</p>
<p>该类封装了对Bean的销毁过程，用来处理Bean的销毁逻辑。</p>
<p>对于销毁逻辑，运用了适配器模式和桥接模式的思想，同时实现了接口的销毁操作和自定义的销毁操作</p>
<ul>
<li>用到的适配器模式思想：允许那些没有实现 <code>DisposableBean</code>接口的类，通过指定一个销毁方法名来整合进Spring的生命周期管理。</li>
</ul>
</li>
<li><p><code>AbstractAutowireCapableBeanFactory</code>通过 <code>invokeInitMethods</code>方法和 <code>initializeBean</code>方法<code>&lt;span style=&quot;color:blue&quot;&gt;</code>将初始化操作加到了生命周期中，然后将可被销毁的bean注册到一个专门的注册表中，用来追踪需要执行销毁方法的Bean</p>
</li>
</ol>
<h2 id="2-重点"><a href="#2-重点" class="headerlink" title="2. 重点"></a>2. 重点</h2><p>对于可被销毁的bean，Spring将其专门在 <code>doCreateBean()</code>方法中被识别，将其注册在一个专门的集合中，用来理那些具体需要销毁操作的Bean。</p>
<p>这是一个用来追踪、管理和调度销毁逻辑的机制。通过这种机制，再加上 <code>DisposableBeanAdapter</code>和销毁方法的具体逻辑，确保每个可被销毁的Bean只被注册一次，销毁的时候也只被销毁一次。</p>
<h2 id="3-适配器模式的应用"><a href="#3-适配器模式的应用" class="headerlink" title="3. 适配器模式的应用"></a>3. 适配器模式的应用</h2><p>适配器模式主要用于连接两个不兼容的接口，使它们可以一起工作。在 <code>DisposableBeanAdapter</code>的情况下，这个模式主要体现在它允许那些没有实现 <code>DisposableBean</code>接口的类，通过指定一个销毁方法名来整合进Spring的生命周期管理。适配器在这里作用是允许不同类型的对象（实现了 <code>DisposableBean</code>和未实现的）以统一的方式进行销毁处理。<strong>将不同的销毁机制适配到一个统一的接口。</strong></p>
<p><strong>与传统适配器模式的区别</strong></p>
<ul>
<li><strong>接口转换</strong>：在传统的适配器模式中，适配器通常是为了转换一个已存在的接口到另一个接口，以满足客户端的期望。而在 <code>DisposableBeanAdapter</code>的情况中，适配的不是接口之间的直接转换，而是提供一种机制来适配那些未直接实现特定接口（这里是 <code>DisposableBean</code>）的类，使其能够以统一的方式被处理。</li>
<li><strong>逻辑增强</strong>：<code>DisposableBeanAdapter</code> 还包含了一些逻辑判断，例如防止同名方法被重复调用的情况，这超出了传统适配器模式的简单接口转换功能。</li>
</ul>
<h1 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h1><p>重点就在一个感知，使实现了接口的类能够访问完整的 <code>BeanFactory</code>或 <code>ApplicationContext</code></p>
<p>增加了 <code>Aware</code>接口、<code>BeanFactoryAware</code>接口、<code>ApplicationContextAware</code>接口</p>
<h2 id="1-BeanFactoryAware"><a href="#1-BeanFactoryAware" class="headerlink" title="1. BeanFactoryAware"></a>1. BeanFactoryAware</h2><p>实现方式：在 <code>initializeBean</code>方法中判断bean是否实现了 <code>BeanFactoryAware</code>接口，如果实现，那就在 <code>initializeBean</code>方法中 执行该Bean的 <code>setBeanFactory</code>方法，将 <code>BeanFactory</code>的引用传递给Bean的成员变量，<code>doCreate</code>方法将 <code>initializeBean</code>加入实例化过程中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">		((BeanFactoryAware) bean).setBeanFactory(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ApplicationContextAware"><a href="#2-ApplicationContextAware" class="headerlink" title="2. ApplicationContextAware"></a>2. ApplicationContextAware</h2><p>实现方式：通过 <code>BeanPostProcessor</code>，定义一个 <code>BeanPostProcessor</code>的实现类 <code>ApplicationContextAwareProcessor</code>，通过refresh方法将其添加进生命周期中，将 <code>ApplicationConext</code>赋给bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">		((ApplicationContextAware) bean).setApplicationContext(applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//添加ApplicationContextAwareProcessor，让继承自ApplicationContextAware的bean能感知bean</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计模式：体现了建造者模式的好处，现在要添加功能，直接实现好子功能，将其添加进指挥者方法中就好，解耦，拓展性强</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>增加prototype的支持</p>
<ol>
<li>BeanDefiniton加属性和方法（<code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>重点</strong>，有点绕）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinition</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首先是默认值，scope默认是singleton，所以singleton=true、prototype=false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> <span class="string">&quot;singleton&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> <span class="string">&quot;prototype&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> SCOPE_SINGLETON;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解析xml文件后获得了开发者设置的作用域，将作用域赋值给scope，然后对应改变singleton和prototype的boolen值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    <span class="built_in">this</span>.singleton = SCOPE_SINGLETON.equals(scope);</span><br><span class="line">    <span class="built_in">this</span>.prototype = SCOPE_PROTOTYPE.equals(scope);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>XmlBeanDefinitionReader增加了解析scope的步骤</li>
<li>在doCreateBean方法中加了两步判断，添加单例池方法与销毁方法执行之前要先判断该Bean是否为单例，否则不执行这两个方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// doCreateBean方法</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">	addSingleton(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// registerDisposableBeanIfNecessary方法</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;</span><br><span class="line">		registerDisposableBean(beanName, <span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, beanDefinition));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在ApplicationContext提前实例化Bean之前，也加了一步该Bean是否为单例的判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	beanDefinitionMap.forEach((beanName, beanDefinition) -&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span>(beanDefinition.isSingleton())&#123;</span><br><span class="line">			getBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//1.2.3.4...</span></span><br><span class="line">    <span class="comment">// 5. 提前实例化单例Bean，提高应用程序的启动性能和响应速度</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>自定义一个实现了FactoryBean的工厂类，此工厂方式第一次产生的Bean实例不会存储到单例池singletonObjects中，会存储到 factoryBeanObjectCache 缓存池中。首次请求会创建一个对象并缓存该对象，后续请求将直接把返回缓存的对象存到单例池中，提高性能。</p>
<p>就是一种注入Bean的方法，FactoryBean接口是Spring内部为工厂方法注入提供了内部的实现，使之更规范，更高效。</p>
<p>代码演示（底层+应用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FactoryBean接口：一个用于创建特定类型对象（T）的工厂模式接口。实现这个接口允许自定义Bean的创建过程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义工厂中得到Bean的方法</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory：支持单例注册和Bean的配置管理</span></span><br><span class="line"><span class="comment">// 缓存池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; factoryBeanObjectCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">shareInstance</span> <span class="operator">=</span> getSingleton(name);</span><br><span class="line">    <span class="keyword">if</span> (shareInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getObjectForBeanInstance(shareInstance, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> getBeanDefinition(name);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> createBean(name, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> getObjectForBeanInstance(bean, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从特定Bean实例中获得相应的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(Object beanInstance, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> beanInstance;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> FactoryBean) &#123; <span class="comment">// 获得实现了FactoryBean接口的对象</span></span><br><span class="line">        <span class="type">FactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (FactoryBean) beanInstance; <span class="comment">// 转换类型</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (factoryBean.isSingleton()) &#123;</span><br><span class="line">                object = <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">                    object = factoryBean.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                object = factoryBean.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;FactoryBean threw exception on object[&quot;</span> + beanName + <span class="string">&quot;] creation&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Car&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        car.setBrand(brand);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.common.CarFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brand&quot;</span> <span class="attr">value</span>=<span class="string">&quot;porsche&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test方法</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:factory-bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;car&quot;</span>, Car.class);</span><br></pre></td></tr></table></figure>

<p>有三种工厂方法实例化的方式，前两种只会使用，factory-bean和factory-method Bean标签底层还没看</p>
<h1 id="容器事件和事件监听器"><a href="#容器事件和事件监听器" class="headerlink" title="容器事件和事件监听器"></a>容器事件和事件监听器</h1><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><h3 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h3><p>主要分为四块儿：广播器、发布、事件、监听器</p>
<p>通俗说就是：谁要发、怎么发、发的是什么、谁接收</p>
<h3 id="1-2-实现方式"><a href="#1-2-实现方式" class="headerlink" title="1.2 实现方式"></a>1.2 实现方式</h3><p>广播器中创建一个存储监听器的容器，当广播器要广播事件时，遍历容器中的监听器，逐个将事件作为参数传递给监听器的 <code>onApplicationEvent</code> <code>定义当特定类型的事件发生时应该执行的行为</code>方法</p>
<h3 id="1-3-Spring对该模式的使用"><a href="#1-3-Spring对该模式的使用" class="headerlink" title="1.3 Spring对该模式的使用"></a>1.3 <strong>Spring对该模式的使用</strong></h3><p>利用了Spring IoC和DI的特性：</p>
<ol>
<li><p>监听器类通过配置文件被Spring容器自动管理</p>
</li>
<li><p>内部将其分为两步</p>
<ul>
<li><p>存储监听器阶段</p>
<p>解析完配置文件后，Spring提前创建监听器类，将自定义监听器存储进监听器容器中，方便后续调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:event-and-event-listener.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>发布事件 监听器接收阶段</p>
<p>广播器发送事件后，Spring从监听器容器中获取监听器，并传递事件参数 执行监听器对应方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(applicationContext));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Spring中内嵌了 <code>上下文刷新事件及监听器</code>和 <code>上下文关闭事件及监听器</code></p>
<p>这些都在AbstractApplicationContext中配置，如果你忘了，建议看着refresh方法自己过一遍(就在这个类里)</p>
</li>
</ol>
<h2 id="2-广播器"><a href="#2-广播器" class="headerlink" title="2. 广播器"></a>2. 广播器</h2><ol>
<li><p><code>ApplicationEventMulticaster</code>广播器顶层接口(聚合了ApplicationListener)，实现了广播器最基础的几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventMulticaster</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>AbstractApplicationEventMulticaster</code>，实现BeanFactoryAware接口、存储事件监听器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationEventMulticaster</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventMulticaster</span>, BeanFactoryAware &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;ApplicationEvent&gt;&gt; applicationListeners = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>SimpleApplicationEventMulticaster</code> 广播器的简单实现，主要是用来实现 <code>将一个特定的事件广播给所有注册的监听器</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">// ApplicationEventMulticaster接口方法的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;ApplicationEvent&gt; applicationListener : applicationListeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsEvent(applicationListener, event)) &#123;</span><br><span class="line">            applicationListener.onApplicationEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-发布"><a href="#3-发布" class="headerlink" title="3. 发布"></a>3. 发布</h2><p>分为两种，Spring内嵌发布和手动发布</p>
<h3 id="3-1-内嵌发布"><a href="#3-1-内嵌发布" class="headerlink" title="3.1 内嵌发布"></a>3.1 内嵌发布</h3><p>关键类在于 <code>ApplicationContext</code></p>
<p><code>ApplicationContext</code>继承了 <code>ApplicationEventPublisher</code>，<code>AbstractApplicationContext</code>实现了该接口的 <code>publishEvent</code>发布事件方法，用来发布 <code>ContextRefreshedEvent</code>上下文刷新事件和 <code>ContextClosedEvent</code>上下文关闭事件。</p>
<h3 id="3-2-手动发布"><a href="#3-2-手动发布" class="headerlink" title="3.2 手动发布"></a>3.2 手动发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就是自己在Test方法中手动传入自定义事件并将其发布</span></span><br><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(applicationContext));</span><br></pre></td></tr></table></figure>

<h3 id="3-3-发布的实现过程"><a href="#3-3-发布的实现过程" class="headerlink" title="3.3 发布的实现过程"></a>3.3 发布的实现过程</h3><p>（见广播器第三点）</p>
<p>遍历容器中的监听器，逐个将事件作为参数传递给监听器的 <code>onApplicationEvent</code> <code>定义当特定类型的事件发生时应该执行的行为</code>方法，触发该方法说明广播器成功发布，监听器也从BeanFactory中获得了想要的信息</p>
<h2 id="4-事件-监听器"><a href="#4-事件-监听器" class="headerlink" title="4. 事件+监听器"></a>4. 事件+监听器</h2><p>都分为Spring内嵌和自定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个典型的事件(实现Application的方法)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 参数source：事件最初发生的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果source是null，抛出IllegalArgumentException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationContextEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个 ApplicationContext 类型的对象</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;提供一种安全和方便的方式来访问触发事件的应用程序上下文。通过这个方法，事件的处理者可以轻松获取到事件关联的 Spring 容器，进而操作容器中的各种 Bean 或查询容器的状态。&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ApplicationContext) getSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextClosedEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContextEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContextClosedEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextClosedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;监听上下文关闭&quot;</span> + <span class="built_in">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextRefreshedEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContextEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContextRefreshedEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextRefreshedEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听刷新事件：&quot;</span> + <span class="built_in">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContextEvent</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CustomEvent</span><span class="params">(ApplicationContext source)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(source);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;CustomEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义事件监听器：打印监听器类的名称&quot;</span> + <span class="built_in">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-实现BeanFactoryAware接口的作用"><a href="#5-实现BeanFactoryAware接口的作用" class="headerlink" title="5. 实现BeanFactoryAware接口的作用"></a>5. 实现BeanFactoryAware接口的作用</h2><p>以下内容生成字ChatGPT4，截止4.24 13:29，我还没太明白</p>
<p>让我通过一个具体的例子来解释为什么 <code>AbstractApplicationEventMulticaster</code> 实现 <code>BeanFactoryAware</code> 接口是有用的，以及这种感知 <code>BeanFactory</code> 的能力如何在实际应用中发挥作用。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 Spring 的事件驱动架构中，<code>ApplicationEventMulticaster</code> 负责处理所有的事件发布任务，即将事件从发布者发送到所有相关的监听器。为了做到这一点，事件多播器需要知道所有注册的事件监听器。在大型应用中，监听器可能会很多，并且它们可能有不同的依赖和初始化时间。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>假设你有一个大型电商平台，其中包含一个订单服务，订单服务在创建订单后会发布一个 <code>OrderCreatedEvent</code>。你希望在订单创建后执行多个操作，比如发送确认邮件给用户、更新库存系统、记录订单统计信息等。每个操作由不同的服务（或监听器）处理。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><strong>定义事件：</strong> 首先定义 <code>OrderCreatedEvent</code>，这个事件包含了订单的所有相关信息。</li>
<li><strong>事件监听器：</strong> 你可能会定义多个监听器如 <code>EmailNotificationListener</code>、<code>InventoryUpdateListener</code>、<code>OrderStatisticsListener</code> 等，每个监听器监听 <code>OrderCreatedEvent</code>。</li>
<li><strong>事件多播器：</strong> 你使用 <code>AbstractApplicationEventMulticaster</code> 来广播 <code>OrderCreatedEvent</code> 到所有相关的监听器。</li>
</ol>
<h3 id="BeanFactoryAware-的作用"><a href="#BeanFactoryAware-的作用" class="headerlink" title="BeanFactoryAware 的作用"></a>BeanFactoryAware 的作用</h3><p>在这个场景中，<code>AbstractApplicationEventMulticaster</code> 需要知道所有关心 <code>OrderCreatedEvent</code> 的监听器。这些监听器可能是在不同的地方定义并通过 Spring 管理。<code>AbstractApplicationEventMulticaster</code> 实现 <code>BeanFactoryAware</code> 的作用就体现出来了：</p>
<ul>
<li><strong>动态感知监听器：</strong> <code>AbstractApplicationEventMulticaster</code> 可以利用 <code>BeanFactory</code> 动态地获取所有注册为 <code>ApplicationListener</code> 的 Bean。这意味着无论何时添加新的监听器或移除旧的监听器，<code>AbstractApplicationEventMulticaster</code> 都能即时地更新其监听器列表，无需重新启动应用或重新配置。</li>
<li><strong>灵活的依赖注入：</strong> 有些监听器可能依赖于其他的服务或组件，这些依赖需要在监听器实例化之前解决。通过 <code>BeanFactory</code>，<code>AbstractApplicationEventMulticaster</code> 可以确保在调用监听器前，所有依赖都已正确注入。</li>
<li><strong>按需加载：</strong> 在某些情况下，监听器可能配置为懒加载，即只有在实际需要时才创建实例。<code>AbstractApplicationEventMulticaster</code> 通过 <code>BeanFactory</code> 可以按需创建和获取这些懒加载的监听器，从而优化资源使用和启动时间。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过实现 <code>BeanFactoryAware</code> 接口，<code>AbstractApplicationEventMulticaster</code> 获得了一个关键的能力：直接访问 Spring 的 <code>BeanFactory</code>，从而能够动态管理和调用应用中的所有事件监听器。这种设计大大增加了应用的灵活性和可扩展性，使得开发者可以更容易地添加和修改事件监听器，而不会影响到应用的其他部分。这对于维护大型、复杂的 Spring 应用来说是非常重要的。</p>
<h1 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h1><p><strong>提前将类创建好，使用时直接调用以提高性能加快速度，这体现了什么设计模式或者设计思想呢？</strong></p>
<p>by ChatGPT4</p>
<p>提前将类创建好，使用时直接调用以提高性能和加快速度的做法体现了<strong>对象池（Object Pool）模式</strong>的设计思想。此外，这种策略还涉及到<strong>懒加载（Lazy Initialization）</strong>和<strong>预先初始化（Eager Initialization）</strong>的概念，这两者通常用来平衡启动性能与运行时性能。以下是这些设计模式或设计思想的详细介绍：</p>
<h2 id="1-对象池模式"><a href="#1-对象池模式" class="headerlink" title="1. 对象池模式"></a>1. 对象池模式</h2><p>对象池模式是一种创建对象并在池中保持它们的设计模式，目的是重用昂贵的对象来提高应用程序的性能和资源利用率。当系统需要一个对象时，它会从池中取出一个，使用后再放回池中而不是销毁。这种模式在需要频繁创建和销毁对象的情况下特别有用，比如数据库连接池。</p>
<p>在 Spring 框架中，单例模式的使用在某种程度上类似于对象池模式，因为每个单例 Bean 只被创建一次，并在整个容器中重用。</p>
<h2 id="2-懒加载"><a href="#2-懒加载" class="headerlink" title="2. 懒加载"></a>2. 懒加载</h2><p>懒加载是指仅在首次需要时才创建对象的策略。这种方式可以延迟对象的创建成本，直到确实需要该对象时才发生，有助于减少应用程序启动时的初始化负载。Spring 允许 Bean 在被首次访问时才进行初始化，这通常通过设置 <code>lazy-init=&quot;true&quot;</code> 来配置。</p>
<h2 id="3-预先初始化（预加载）"><a href="#3-预先初始化（预加载）" class="headerlink" title="3. 预先初始化（预加载）"></a>3. 预先初始化（预加载）</h2><p>预先初始化或预加载是指在应用程序启动时提前创建并初始化对象，这有助于减少对象首次使用时的延迟。这在 Spring 中通过容器的启动过程中的 Bean 初始化阶段体现，其中所有非懒加载的单例 Bean 都会在应用程序上下文启动时创建和配置。</p>
<p>预先初始化可以减少运行时的延迟，因为所有必需的 Bean 在应用程序需要它们之前已经准备就绪，从而提高了响应性能。然而，这可能会增加应用程序启动时间。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过预先创建和初始化对象，Spring 通过减少每次对象请求的创建时间来优化性能。这种策略非常适合那些创建成本高但使用频率高的对象。结合懒加载，开发者可以根据具体的性能和资源利用需求灵活选择初始化策略。这两种策略的应用表明了 Spring 的设计非常注重提供灵活的性能优化工具，使得开发者可以根据应用的具体需要来调整其行为。</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h1><p>AOP动态代理，这种方式允许在不修改目标对象代码的情况下，动态地添加额外的行为（如日志、事务管理等），这是AOP编程范式的核心优势。</p>
<p>从以下几个角度讲起</p>
<ol>
<li>动态代理-JDK</li>
<li>动态代理-CGLIB</li>
<li>AOP代理工厂</li>
<li>常用Advice</li>
<li><code>PointcutAdvisor</code>: Pointcut和Advice的组合</li>
<li>动态代理融入生命周期</li>
<li>拦截器链</li>
</ol>
<h1 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h1><p><code>AspectJExpressionPointcut</code></p>
<h2 id="1-原语"><a href="#1-原语" class="headerlink" title="1. 原语"></a>1. 原语</h2><p>原语（Primitives）通常指的是提供基本功能的最小构件。</p>
<p>在 AspectJ（一种面向切面的编程语言）中，切点原语（Pointcut Primitives）是构建切点表达式的基础元素，它们定义了何处和何时应用切面的规则。切点原语直接对应于程序执行的某些具体事件或动作，如方法调用 <code>execution</code>、方法执行 <code>call</code>等。</p>
<h2 id="2-常用对象"><a href="#2-常用对象" class="headerlink" title="2. 常用对象"></a>2. 常用对象</h2><h3 id="2-1-PointcutPrimitive"><a href="#2-1-PointcutPrimitive" class="headerlink" title="2.1 PointcutPrimitive"></a>2.1 PointcutPrimitive</h3><p>枚举类型，定义了不同的切点原语（切点的基本类型）</p>
<h3 id="2-2-PointcutParser"><a href="#2-2-PointcutParser" class="headerlink" title="2.2 PointcutParser"></a>2.2 PointcutParser</h3><p>解析切点表达式的解析器。它将字符串形式的切点表达式转换成 <code>PointcutExpression</code> 对象</p>
<h3 id="2-3-PointcutExpression"><a href="#2-3-PointcutExpression" class="headerlink" title="2.3 PointcutExpression"></a>2.3 PointcutExpression</h3><p>这个类代表一个切点表达式，通常用于存储和管理切点表达式字符串</p>
<h2 id="3-代码："><a href="#3-代码：" class="headerlink" title="3. 代码："></a>3. 代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title class_">Pointcut</span>, ClassFilter, MethodMatcher &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;PointcutPrimitive&gt; SUPPORTED_PRIMITIVES = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PointcutExpression pointcutExpression;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法接收一个AspectJ表达式字符串作为参数。这个表达式用来定义何时触发切面。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AspectJExpressionPointcut</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过方法获取一个 PointcutParser 实例，这个解析器支持指定的原语和类加载器。</span></span><br><span class="line">        <span class="type">PointcutParser</span> <span class="variable">pointcutParser</span> <span class="operator">=</span> PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(SUPPORTED_PRIMITIVES, <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 使用上述解析器解析传入的AspectJ表达式，并将解析结果存储在 pointcutExpression 字段中</span></span><br><span class="line">        pointcutExpression = pointcutParser.parsePointcutExpression(expression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类匹配器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pointcutExpression.couldMatchJoinPointsInType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法匹配器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pointcutExpression.matchesMethodExecution(method).alwaysMatches();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态代理-JDK"><a href="#动态代理-JDK" class="headerlink" title="动态代理-JDK"></a>动态代理-JDK</h1><p><code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>强调</strong>：JDK动态代理一切基于接口，原始类和代理类是基于同一个接口的不同子实现类，二者之间的转换要通过接口来实现，倘若二者直接相互转换，便会出现报错。</p>
<h2 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="1. 简单示例"></a>1. 简单示例</h2><p>（简单了解JDK动态代理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">                station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;invoke方法执行了&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;代售点收取一定的服务费用(jdk动态代理 )&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-缺点"><a href="#1-1-缺点" class="headerlink" title="1.1 缺点"></a>1.1 缺点</h3><p>耦合度太高</p>
<ul>
<li>目标对象耦合死了</li>
<li>增强逻辑耦合死了</li>
<li>逻辑都集中在一个方法中</li>
</ul>
<h2 id="2-AdvisedSupport"><a href="#2-AdvisedSupport" class="headerlink" title="2. AdvisedSupport"></a>2. AdvisedSupport</h2><p>用来封装AOP需要的代理对象信息（目标对象、拦截器、方法匹配器）</p>
<p><code>AdvisedSupport</code></p>
<ul>
<li><code>TargetSource</code></li>
<li><code>MethodInterceptor</code></li>
<li><code>MethodMatcher</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;被建议的支持&quot;，用来保存AOP相关的配置信息</span></span><br><span class="line"><span class="comment">// 当创建代理对象时，需要知道目标对象、拦截器、方法匹配器等信息，AdvisedSupport就是用来保存这些信息的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvisedSupport</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line">    <span class="comment">// 拦截器，用于在目标方法调用前后增加额外的逻辑</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line">    <span class="comment">// 方法匹配器，用于判断哪些方法需要被拦截和增强</span></span><br><span class="line">    <span class="keyword">private</span> MethodMatcher methodMatcher;</span><br><span class="line">    <span class="comment">// getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-ReflectiveMethodInvocation"><a href="#3-ReflectiveMethodInvocation" class="headerlink" title="3. ReflectiveMethodInvocation"></a>3. ReflectiveMethodInvocation</h2><p><code>ReflectiveMethodInvocation</code> implements <code>MethodInvocation</code></p>
<p>与Aware接口功能类似，使拦截器能够感知到目标对象、目标方法和方法参数等信息，在保证低耦合的同时还能在重写的invoke方法中调用外部信息，执行更多操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射 方法 调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title class_">MethodInvocation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要通过反射调用的具体方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object[] arguments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveMethodInvocation</span><span class="params">(Object target, Method method, Object[] arguments)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.arguments = arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行原有方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getThis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AccessibleObject <span class="title function_">getStaticPart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-JdkDynamicAopProxy"><a href="#4-JdkDynamicAopProxy" class="headerlink" title="4. JdkDynamicAopProxy"></a>4. JdkDynamicAopProxy</h2><p><code>JdkDynamicAopProxy</code> implements <code>AopProxy</code>, <code>InvocationHandler</code></p>
<p>就是刚刚那段简易示例的Spring-AOP版，解决了高耦合的缺点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理</span></span><br><span class="line"><span class="comment"> * 两个接口：</span></span><br><span class="line"><span class="comment"> *      1. AopProxy 提供代理对象方法</span></span><br><span class="line"><span class="comment"> *      2. InvocationHandler，JDK动态代理技术的一部分，用于处理代理对象的方法调用</span></span><br><span class="line"><span class="comment"> *              调用 处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title class_">AopProxy</span>, InvocationHandler &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getTargetClass(), <span class="built_in">this</span>); <span class="comment">// 第三个参数是InvocationHandler的子实现类，实现了invoke方法，在这里就是this即本类</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 判断是否对一个特定的方法调用应用拦截器，涉及了方法匹配逻辑(就是上面的切点表达式匹配方法)</span></span><br><span class="line">        <span class="keyword">if</span> (advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">            <span class="comment">// 如果匹配，则执行被增强对象的方法</span></span><br><span class="line">            <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> advised.getMethodInterceptor();</span><br><span class="line">            <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(advised.getTargetSource().getTarget(), method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不匹配，那就执行原有方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-InvocationHandler"><a href="#5-InvocationHandler" class="headerlink" title="5. InvocationHandler"></a>5. InvocationHandler</h2><p>java.lang.reflect包下的一个接口</p>
<p><code>InvocationHandler</code> 就像是代理对象的 “管家”，当有人调用代理对象的方法时，实际上是由这个 “管家” 接收到了请求。这个 “管家” 的主要工作就是：</p>
<ul>
<li>接收代理对象的方法调用请求。</li>
<li>根据请求的方法和参数，决定如何处理这个调用。</li>
<li>最后，返回调用结果给调用者。</li>
</ul>
<p>定义了一个方法 <code>invoke()</code>，当代理对象的方法被调用时，<code>invoke()</code> 方法会被调用，代理对象的方法调用会委托给 <code>invoke()</code> 方法来处理。</p>
<p>在 <code>invoke()</code> 方法中，有三个参数：</p>
<ul>
<li><code>proxy</code>：代理对象本身。</li>
<li><code>method</code>：被调用的方法对象，是被代理对象的一个方法。</li>
<li><code>args</code>：方法调用时传递的参数。</li>
</ul>
<p>所以，<code>InvocationHandler</code> 就是一个用来处理代理对象方法调用的接口，它决定了代理对象的行为。</p>
<h2 id="6-执行流程"><a href="#6-执行流程" class="headerlink" title="6. 执行流程"></a>6. 执行流程</h2><p>开发者实现 <code>MethodInterceptor</code>接口，重写 <code>invoke</code>方法自定义逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldServiceInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>AdvisedSupport</code>对象，并为之赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AdvisedSupport advisedSupport;</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WorldService</span> <span class="variable">worldService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldServiceImpl</span>();</span><br><span class="line">    advisedSupport = <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetSource</span>(worldService);</span><br><span class="line">    <span class="type">WorldServiceInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldServiceInterceptor</span>();</span><br><span class="line">    <span class="type">MethodMatcher</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>(<span class="string">&quot;execution(* org.springframework.service.WorldService.explode(..))&quot;</span>).getMethodMatcher();</span><br><span class="line">    advisedSupport.setTargetSource(targetSource);</span><br><span class="line">    advisedSupport.setMethodInterceptor(methodInterceptor);</span><br><span class="line">    advisedSupport.setMethodMatcher(methodMatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递 <code>adviseSupport</code>参数，执行 <code>getProxy</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WorldService</span> <span class="variable">proxy</span> <span class="operator">=</span> (WorldService) <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(advisedSupport).getProxy();</span><br></pre></td></tr></table></figure>

<p><code>getProxy</code>内部调用 <code>Proxy</code>.<code>newProxyInstance</code>方法，创建代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getTargetClass(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个参数为 <code>InvocationHandler</code>的子实现类，重写 <code>InvocationHandler</code>的 <code>invoke</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 判断是否对一个特定的方法调用应用拦截器，涉及了方法匹配逻辑(就是上面的切点表达式匹配方法)</span></span><br><span class="line">    <span class="keyword">if</span> (advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">        <span class="comment">// 如果匹配，则执行被增强对象的方法</span></span><br><span class="line">        <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> advised.getMethodInterceptor();</span><br><span class="line">        <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(advised.getTargetSource().getTarget(), method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不匹配，那就执行原有方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>advised</code>.<code>getMethodInterceptor</code>方法得到用户自定义的拦截器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> advised.getMethodInterceptor();</span><br></pre></td></tr></table></figure>

<p>调用自定义拦截器的 <code>invoke</code>方法（此处 <code>invoke</code>方法的返回值为增强方法的返回值），传递 <code>ReflectiveMethodInvocation</code>参数（使自定义拦截器能够感知目标对象、目标方法和方法参数等信息）。至此执行完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(advised.getTargetSource().getTarget(), method, args));</span><br></pre></td></tr></table></figure>

<h2 id="7-部分原理分析"><a href="#7-部分原理分析" class="headerlink" title="7. 部分原理分析"></a>7. 部分原理分析</h2><p><code>Proxy</code>.<code>newProxyInstance</code>方法在内存中动态生成了一个代理对象</p>
<h3 id="7-1-查看内存中动态代理对象"><a href="#7-1-查看内存中动态代理对象" class="headerlink" title="7.1 查看内存中动态代理对象"></a>7.1 查看内存中动态代理对象</h3><p>使用阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构</p>
<ol>
<li><p>下载好jar包</p>
</li>
<li><p>打开终端，进入jar包所在目录</p>
</li>
<li><p>运行jar包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure></li>
<li><p>选择内存中的Java进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] arthas-boot version: 3.1.1</span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 23712 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">  [2]: 22388 com.intellij.rt.junit.JUnitStarter</span><br><span class="line">  [3]: 20776</span><br></pre></td></tr></table></figure></li>
<li><p>现在idea中得到代理类的全限定类名，不要让程序停止，否则会释放内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(proxyObject.getClass().toString());</span><br></pre></td></tr></table></figure>

<p>然后输入jar + 全限定类名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad jdk.proxy2.$Proxy5</span><br></pre></td></tr></table></figure></li>
<li><p>然后终端就会打印出该类的Java代码，完成了！</p>
</li>
</ol>
<h3 id="7-2-动态代理类分析"><a href="#7-2-动态代理类分析" class="headerlink" title="7.2 动态代理类分析"></a>7.2 动态代理类分析</h3><p><code>java.lang.reflect.Proxy</code>类中，有 <code>InvocationHandler</code>成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只保留关键信息，动态代理类如下（重点全写注释上了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了java.lang.reflect.Proxy类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy5</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">WorldService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m3;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过反射获取WorldService类的explode方法对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;org.springframework.service.WorldService&quot;</span>).getMethod(<span class="string">&quot;explode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，将实现了InvocationHandler的子实现类对象赋给父类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy5(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过invoke方法执行了InvocationHandler的子实现类对象(即真实的拦截器对象)中的拦截器中重写的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">explode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-还不会的地方"><a href="#8-还不会的地方" class="headerlink" title="8. 还不会的地方"></a>8. 还不会的地方</h2><p>java.lang.reflect包下</p>
<ul>
<li>Method.invoke底层原理（应该要学完JVM再看jdk源码）</li>
<li>Proxy底层原理（主要是用到了 <code>newProxyInstance</code>方法）</li>
</ul>
<h2 id="9-设计模式"><a href="#9-设计模式" class="headerlink" title="9. 设计模式"></a>9. 设计模式</h2><h3 id="9-1-代理模式"><a href="#9-1-代理模式" class="headerlink" title="9.1 代理模式"></a>9.1 代理模式</h3><h3 id="9-2-感知设计模式"><a href="#9-2-感知设计模式" class="headerlink" title="9.2 感知设计模式"></a>9.2 感知设计模式</h3><p>Aware和ReflectiveMethodInvocation</p>
<p>这类设计模式使得组件能够感知并操作其所处的上下文环境，从而提供更为灵活和动态的行为。</p>
<p>在某种程度上，<code>ReflectiveMethodInvocation</code>和 Spring 中的 Aware 接口确实有一些共通之处，因为它们都涉及到对象在运行时对外部资源的感知或依赖。让我们来分析一下它们之间的相似之处：</p>
<ol>
<li><strong>感知外部资源</strong>：<ul>
<li><code>Aware</code> 接口：Spring 中的 <code>Aware</code> 接口（如 <code>ApplicationContextAware</code>、<code>BeanFactoryAware</code>）使 Bean 能够感知到容器的存在或者其他资源，比如获取应用程序上下文或者 Bean 工厂。</li>
<li><code>ReflectiveMethodInvocation</code>：在这行代码中，<code>ReflectiveMethodInvocation</code> 对象被创建，并传递给 <code>methodInterceptor</code> 的 <code>invoke()</code> 方法。这个对象使拦截器能够感知到目标对象、目标方法和方法参数等信息。</li>
</ul>
</li>
<li><strong>依赖注入</strong>：<ul>
<li><code>Aware</code> 接口：实现了 <code>Aware</code> 接口的类通常会通过依赖注入的方式获取所需的资源。</li>
<li><code>ReflectiveMethodInvocation</code>：这行代码中的 <code>ReflectiveMethodInvocation</code> 对象通过构造函数的方式接收了目标对象、目标方法和方法参数等信息，这可以看作是一种依赖注入的方式。</li>
</ul>
</li>
<li><strong>解耦合</strong>：<ul>
<li><code>Aware</code> 接口：通过 Aware 接口，Bean 与容器或其他资源之间的耦合度降低了，使得 Bean 更加灵活和可扩展。</li>
<li><code>ReflectiveMethodInvocation</code>：这行代码中的 <code>ReflectiveMethodInvocation</code> 对象充当了方法调用的上下文，使得拦截器可以在方法调用时执行额外的逻辑，而不需要直接与目标对象进行交互，从而降低了拦截器与目标对象之间的耦合度。</li>
</ul>
</li>
</ol>
<p>虽然这两者在具体实现和应用场景上有所不同，但它们确实都涉及到了对象在运行时对外部资源的感知或依赖，以及为了解耦合而采用的设计思想。</p>
<h1 id="动态代理-CGLIB"><a href="#动态代理-CGLIB" class="headerlink" title="动态代理-CGLIB"></a>动态代理-CGLIB</h1><h1 id="AOP代理工厂"><a href="#AOP代理工厂" class="headerlink" title="AOP代理工厂"></a>AOP代理工厂</h1><p>判断是否使用cglib代理</p>
<h2 id="1-JDK-CGLIB-动态代理比较"><a href="#1-JDK-CGLIB-动态代理比较" class="headerlink" title="1. JDK CGLIB 动态代理比较"></a>1. JDK CGLIB 动态代理比较</h2><p>面试题</p>
<p>都还学的不够深，jdk要看反射源码去，cglib要去看cglib源码</p>
<h1 id="常用Advice"><a href="#常用Advice" class="headerlink" title="常用Advice"></a>常用Advice</h1><p>以 <code>BeforeAdvice</code>为例</p>
<h2 id="1-执行流程"><a href="#1-执行流程" class="headerlink" title="1. 执行流程"></a>1. 执行流程</h2><p>（跟JDK动态代理执行流程差不多，中间有点不一样的地方）</p>
<p>开发者实现 <code>MethodBeforeAdvice</code>，重写 <code>before()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldServiceBeforeAdvice</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] arg, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeforeAdvice: do something before the earth explodes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键类 <code>MethodBeforeAdviceInterceptor</code> 拦截器 聚合 <code>MethodBeforeAdvice</code>通知类，在 <code>invoke()</code>方法中调用通知类的 <code>before()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodBeforeAdviceInterceptor implements MethodInterceptor 拦截器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于在目标方法执行前拦截并执行相应的方法前通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合通知类，集成通知类的同时降低耦合度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在执行被清理方法之前，先执行before advice操作</span></span><br><span class="line">        <span class="comment">// 给before传递参数，调用开发者的MethodBeforeAdvice子实现类中重写的invoke方法</span></span><br><span class="line">        <span class="built_in">this</span>.advice.before(invocation.getMethod(), invocation.getArguments(), invocation.getThis());</span><br><span class="line">        <span class="comment">// 返回的就是返回值，invoke调用的实际方法的返回值（原有对象或代理对象）</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现通知类，将通知类作为对象new前置方法拦截器，将拦截器赋给 <code>advisedSupport</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeforeAdvice</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 设置BeforeAdvice</span></span><br><span class="line">    <span class="type">WorldServiceBeforeAdvice</span> <span class="variable">beforeAdvice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldServiceBeforeAdvice</span>();</span><br><span class="line">    <span class="type">MethodBeforeAdviceInterceptor</span> <span class="variable">methodBeforeAdviceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodBeforeAdviceInterceptor</span>(beforeAdvice); <span class="comment">// 把前置通知给了拦截器</span></span><br><span class="line">    <span class="comment">// 它把@Before中设置的拦截器给覆盖了</span></span><br><span class="line">    advisedSupport.setMethodInterceptor(methodBeforeAdviceInterceptor);</span><br><span class="line">    <span class="type">WorldService</span> <span class="variable">proxy</span> <span class="operator">=</span> (WorldService) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(advisedSupport).getProxy();</span><br><span class="line">    proxy.explode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是拦截器那里跟JDK动态代理有点不一样，剩下完全一样，将拦截器插入动态代理的过程中</p>
<p>CGLIB动态代理也是一样</p>
<h1 id="PointcutAdvisor-Pointcut和Advice的组合"><a href="#PointcutAdvisor-Pointcut和Advice的组合" class="headerlink" title="PointcutAdvisor: Pointcut和Advice的组合"></a>PointcutAdvisor: Pointcut和Advice的组合</h1><p>Spring-AOP配置切面的另一种方式，通过 <code>Advisor</code>配置</p>
<p>正常来说</p>
<p><code>PointcutAdvisor</code>是将 <code>Pointcut</code>切点表达式对象和 <code>Advice</code>通知类对象在内部组合起来，开发者只需要设置目标对象和 <code>Advisor</code>对象 <code>（内部有通知类和切点表达式，通知类在底层会根据接口自动创建拦截器对象）</code>便能完成AOP的配置。</p>
<p>但是，mini-spring没有实现这部分内容，所以拦截器对象要自己手动设置。</p>
<h2 id="1-和-的区别"><a href="#1-和-的区别" class="headerlink" title="1. &lt;aspect&gt;和 &lt;advisor&gt;的区别"></a>1. <code>&lt;aspect&gt;</code>和 <code>&lt;advisor&gt;</code>的区别</h2><h3 id="代码上-使用上"><a href="#代码上-使用上" class="headerlink" title="代码上 使用上"></a>代码上 使用上</h3><p><code>&lt;aspect&gt;</code>方式是直接根据 <code>Aware</code>接口获得的 <code>BeanFactory</code>对象来给 <code>adviceSupport</code>传递参数，更加灵活</p>
<p><code>&lt;advisor&gt;</code>方式将 <code>Pointcut</code>和 <code>Advice</code>封装，只使用 <code>AspectJExpressionPointcutAdvisor</code>即可，底层通过得到通知类的接口来得到拦截器，对外的接口少，更简单</p>
<p><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/image-20240410213636349.png" alt="image-20240410213636349"></p>
<h1 id="动态代理融入bean生命周期"><a href="#动态代理融入bean生命周期" class="headerlink" title="动态代理融入bean生命周期"></a>动态代理融入bean生命周期</h1><p>先分清aspect标签配置与advisor配置方式的区别</p>
<p>aspect就是什么都自己指定，自己执行通知类型是before还是after等等</p>
<p>advisor通知内部会通过接口的方式来确认通知的类型</p>
<p>所以advisor就可以说是上面的pointcut和advice的组合（待会儿再看看去）</p>
<h2 id="1-执行流程-1"><a href="#1-执行流程-1" class="headerlink" title="1. 执行流程"></a>1. 执行流程</h2><p>xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;worldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.service.WorldServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beforeAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.common.WorldServiceBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pointcutAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">value</span>=<span class="string">&quot;execution(* org.springframework.service.WorldService.explode(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;methodInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beforeAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析配置文件，将以上bean全部注入Spring容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:auto-proxy.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>进入 <code>getBean()</code>方法执行流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WorldService</span> <span class="variable">worldService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;worldService&quot;</span>, WorldService.class);</span><br></pre></td></tr></table></figure>

<p><code>AbstractBeanFactory</code>中的 <code>getBean()</code>方法，调用 <code>AbstractAutowireCapableBeanFactory</code>的 <code>createBean()</code>方法，传递 <code>beanName</code>和 <code>beanDefinition</code>参数（后面需要用它俩来生成）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 如果bean需要代理，调用resolveBeforeInstantiation(实例化之前解析)返回代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, beanDefinition);</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doCreateBean(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>resolveBeforeInstantiation()</code>方法获取实例化好的代理Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 首先，调用applyBeanPostProcessorsBeforeInstantiation方法尝试获取一个bean实例。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applyBeanPostProcessorsBeforeInstantiation(beanDefinition.getBeanClass(), beanName);</span><br><span class="line">    <span class="comment">// 2. 如果获取到了，那么会再调用applyBeanPostProcessorsAfterInitialization对这个bean实例进行后续处理</span></span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>applyBeanPostProcessorsBeforeInstantiation</code>方法，遍历已注册的 <code>BeanPostProcessor</code>，如果存在 <code>BeanPostProcessor</code>实现了 <code>InstantiationAwareBeanPostProcessor</code>接口，则说明该 <code>BeanPostProcessor</code>会内部实现了 <code>postProcessBeforeInstantiation()</code>方法，能够根据 <code>beanClass</code>和 <code>beanName</code>生成增强后的代理对象，从而替代原来的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获得所有实现了InstantiationAwareBeanPostProcessor接口的BeanPostProcessor</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 2. 获得每一个后处理器的postProcessBeforeInstantiation方法返回值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ((InstantiationAwareBeanPostProcessor) beanPostProcessor).postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="comment">/* 3. 如果这个方法返回一个非null对象，表示通过代理或其他方式已经处理了bean的实例化，</span></span><br><span class="line"><span class="comment">                  因此不需要再进行标准的实例化过程。该对象会被直接返回并终止后续处理器的调用。*/</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 4. 如果所有的InstantiationAwareBeanPostProcessor都没有提前实例化bean，</span></span><br><span class="line"><span class="comment">          那么applyBeanPostProcessorsBeforeInstantiation方法将返回null，</span></span><br><span class="line"><span class="comment">          表示标准实例化流程应继续进行。*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说 <code>DefaultAdvisorAutoProxyCreator</code>就相当于一个自动创建代理对象的 <code>BeanPostProcessor</code>，需要在配置文件中将其注入Spring容器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>DefaultAdvisorAutoProxyCreator</code>实现 <code>InstantiationAwareBeanPostProcessor</code>接口和 <code>BeanFactoryAware</code>接口。</p>
<p><code>postProcessorBeforeInstantiation()</code>方法实现逻辑，就是通过 <code>Aware</code>接口感知到的 <code>BeanFactory</code>来获取Spring容器中拦截器的各种信息，并由此创建出 <code>advisedSupport</code>，然后使用 <code>ProxyFactory.getProxy()</code>方法创建出对应的代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于实现了BeanFactoryAware接口，此方法用于注入BeanFactory。</span></span><br><span class="line"><span class="comment">     * DefaultListableBeanFactory使用BeanFactory来访问容器中的beans和其他配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Bean实例化之前，检查是否有任何AspectJExpressionPointcutAdvisor适用于即将实例化的bean。</span></span><br><span class="line"><span class="comment">     * 如果找到匹配的advisor的话，那就为bean创建一个代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 实例化</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 1. 检查传入的参数是否为基础设施类，避免死循环</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从BeanFactory中获取所有AspectJExpressionPointcutAdvisor，遍历它们来查找可以应用于当前 bean 类的 advisor。</span></span><br><span class="line">        Collection&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory.getBeansOfType(AspectJExpressionPointcutAdvisor.class).values();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">                <span class="type">ClassFilter</span> <span class="variable">classFilter</span> <span class="operator">=</span> advisor.getPointcut().getClassFilter();</span><br><span class="line">                <span class="comment">// 3. 如果找到匹配的 advisor，使用 ProxyFactory 创建一个代理对象，并立即返回这个代理对象，从而替代标准的 bean 实例化流程。</span></span><br><span class="line">                <span class="keyword">if</span> (classFilter.matches(beanClass)) &#123;</span><br><span class="line">                    <span class="type">AdvisedSupport</span> <span class="variable">advisedSupport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanFactory.getInstantiationStrategy().instantiate(beanDefinition);</span><br><span class="line">                    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetSource</span>(bean);</span><br><span class="line">                    advisedSupport.setTargetSource(targetSource);</span><br><span class="line">                    advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">                    advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回代理对象</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(advisedSupport).getProxy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;Error create proxy bean for: &quot;</span> + beanName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 辅助方法:检查传入的参数是否为基础设施类(例如 Advice、Pointcut 或 Advisor)</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 避免代理这些类型的类，因为这可能导致循环依赖和配置错误。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Advice.class.isAssignableFrom(beanClass)</span><br><span class="line">                || Pointcut.class.isAssignableFrom(beanClass)</span><br><span class="line">                || Advisor.class.isAssignableFrom(beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化前 Bean后处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化后 Bean后处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过之前的方法一层层将代理对象返回给 <code>creatBean</code>方法，然后被创建的对象在 <code>AbstractBeanFactory</code>的 <code>getBean()</code>方法中调用的 <code>getObjectForBeanInstance()</code>方法存储进单例池中。</p>
<p>至此流程结束。（但还不完美，如下）</p>
<h2 id="2-缺陷"><a href="#2-缺陷" class="headerlink" title="2. 缺陷"></a>2. 缺陷</h2><p><strong>代码中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodBeforeAdviceInterceptor</span> <span class="variable">methodBeforeAdviceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodBeforeAdviceInterceptor</span>(<span class="keyword">new</span> <span class="title class_">WorldServiceBeforeAdvice</span>());</span><br></pre></td></tr></table></figure>

<p>手动将实现了前置通知接口的通知类当作参数赋给Spring内部的 <code>MethodBeforeAdviceInterceptor</code>类，而 <code>advisor</code>配置方式应当能够根据接口自动识别要创建的拦截器对象</p>
<p><strong>xml文件中</strong>，与Spring官方配置的对比</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--用于自动生成代理类的一个对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--adviceSupport需要的三个参数：目标对象、拦截器对象、切点表达式--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1. 目标对象--&gt;</span><span class="comment">&lt;!--和Spring官方一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;worldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.service.WorldServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通知对象，拦截器成员变量--&gt;</span><span class="comment">&lt;!--和Spring官方一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beforeAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.common.WorldServiceBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Spring官方直接将通知类和切点表达式赋给Advisor对象，由advice内部根据自定义通知类实现的接口来创建拦截器(切面)--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;aop:config&gt;</span></span><br><span class="line"><span class="comment">        &lt;aop:advisor advice-ref=&quot;worldServiceBeforeAdvice&quot; pointcut=&quot;execution(* org.springframework.service.WorldService.explode(..))&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;/aop:config&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mini-spring是按以下做法做的--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2. 拦截器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--成员变量为通知对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beforeAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Advisor对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pointcutAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3. 切点表达式对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">value</span>=<span class="string">&quot;execution(* org.springframework.service.WorldService.explode(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2. 拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;methodInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--Spring官方的第二种做法，根据切点表达式和通知类创建拦截器对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    AOP配置</span></span><br><span class="line"><span class="comment">    &lt;aop:config&gt;</span></span><br><span class="line"><span class="comment">        定义切面</span></span><br><span class="line"><span class="comment">        &lt;aop:aspect ref=&quot;methodInterceptor&quot;&gt;</span></span><br><span class="line"><span class="comment">            定义切点</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id=&quot;explodePointcut&quot; expression=&quot;execution(* org.springframework.service.WorldService.explode(..))&quot;/&gt;</span></span><br><span class="line"><span class="comment">            应用前置通知</span></span><br><span class="line"><span class="comment">            &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;explodePointcut&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/aop:aspect&gt;</span></span><br><span class="line"><span class="comment">    &lt;/aop:config&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果自己补全这一块儿的话：</p>
<p><strong>xml部分</strong>，要自己设置一遍 <code>aop-config</code>对应的xml标签，然后自己封装并解析。</p>
<p><strong>代码部分</strong>，要自己能根据自定义通知类实现的接口 实例化对应的拦截器对象并将其传递给 <code>adviceSupport</code>对象做参数。</p>
<p>有点内容呀，能实现，但是暂时来不及了，现在是4月27号，进度有点慢了，这块儿的存疑及解决方案写的挺清楚了，先了解就好，暂时的重点是过完mini-spring、spring-mvc、spring-boot源码，等这些弄完再回头看，<code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>插眼</strong></p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>此处注解的底层实现并融入生命周期 全靠两个后处理器。</p>
<p>常见注解：<a target="_blank" rel="noopener" href="https://www.yoodb.com/spring/spring-annotate.html">Spring基础 - Spring 常用七大类注解 | 素文宅 (yoodb.com)</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xml文件解析器解析到包--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将该包下带了@Component注解的Bean都注入到Spring容器当中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.springframework.bean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将PropertyPlaceholderConfigurer注入Spring容器中，将properties文件作为参数传递进去--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:car.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分为三部分：注解替代bean注入，注解替代bean的属性property注入，xml和@Value注解占位符的解析</p>
<h2 id="1-包扫描、-Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor"><a href="#1-包扫描、-Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor" class="headerlink" title="1. 包扫描、@Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor"></a>1. 包扫描、@Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor</h2><p>向 <code>XmlBeanDefinitionReader</code>xml解析器类中添加对 <code>component-scan</code>和 <code>base-package</code>的解析，接收到 <code>base-package</code>字符串信息。调用 <code>doScan()</code>方法，该方法内部就完成了 <code>beanDefinition</code>的注册等操作。</p>
<p>在xml解析器中调用 <code>ClassPathBeanDefinitionScanner</code>的 <code>doScan()</code>方法，使用注解的方式完全替代了xml解析的方式，除了包扫描还需要xml文件来触发。</p>
<p>该部分先扫描包路径下所有标记了 <code>@Component</code>注解的类，并将其封装为 <code>BeanDefinition</code>对象。然后针对每一个 <code>BeanDefinition</code>设置作用域、确定名称、并注册 <code>AutowiredAnnotationBeanPostProcessor</code>为 <code>BeanDefinition</code>用于后续的属性注入。</p>
<p>主要涉及 <code>XmlBeanDefinitionReader</code>,<code>ClassPathBeanDefinitionScanner</code>,<code>ClassPathScanningCandidateComponentProvider</code>，详见代码。</p>
<h2 id="2-实例化bean，-Value注解扫描，为bean注入属性"><a href="#2-实例化bean，-Value注解扫描，为bean注入属性" class="headerlink" title="2. 实例化bean，@Value注解扫描，为bean注入属性"></a>2. 实例化bean，@Value注解扫描，为bean注入属性</h2><p><code>AutowiredAnnotationBeanPostProcessor</code>在上面被实例化为 <code>BeanDefinition</code>并注册进 <code>BeanDefinition</code>容器，后续 <code>refresh()</code>方法才能通过 <code>beanFactory.preInstantiateSingletons()</code>提前实例化Bean方法调用并执行后处理器方法，从而做到自动执行。</p>
<p>执行流程</p>
<p>实例化Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 5. 提前实例化单例Bean，提高应用程序的启动性能和响应速度</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用 <code>AbstractAutowireCapableBeanFactory</code>的 <code>doCreateBean</code>方法中的 <code>applyBeanPostprocessorsBeforeApplyingPropertyValues</code>方法，触发 <code>AutowiredAnnotationBeanPostProcessor</code>bean后处理器的执行，返回被属性注入、占位符被替换为真实值的完整的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		bean = createBeanInstance(beanDefinition);</span><br><span class="line">		<span class="comment">//在设置bean属性之前，允许BeanPostProcessor修改属性值</span></span><br><span class="line">		applyBeanPostprocessorsBeforeApplyingPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">		<span class="comment">//为bean填充属性</span></span><br><span class="line">		applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">		<span class="comment">//执行bean的初始化方法和BeanPostProcessor的前置和后置处理方法</span></span><br><span class="line">		initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;Instantiation of bean failed&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册有销毁方法的bean</span></span><br><span class="line">	registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line">	<span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">		addSingleton(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改Bean</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyBeanPostprocessorsBeforeApplyingPropertyValues</span><span class="params">(String beanName, Object bean, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">			<span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> ((InstantiationAwareBeanPostProcessor) beanPostProcessor).postProcessPropertyValues(beanDefinition.getPropertyValues(), bean, beanName);</span><br><span class="line">			<span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (PropertyValue propertyValue : pvs.getPropertyValues()) &#123;</span><br><span class="line">					beanDefinition.getPropertyValues().addPropertyValue(propertyValue);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过该接口识别指定解析注解的后处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// bean实例化之后，设置属性之前执行，用于修改属性值（将占位符修改为真实值）</span></span><br><span class="line">	PropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutowiredAnnotationBeanPostProcessor</code> <code>postProcessPropertyValues</code>方法的内部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;一个 Bean 后处理器，主要负责处理带有 <span class="doctag">@Autowired</span> 和 <span class="doctag">@Value</span> 注解的属性的依赖注入。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个类实现了 InstantiationAwareBeanPostProcessor 接口，这意味着它在 Spring 容器实例化 bean 之后，在调用 bean 的初始化方法之前和之后都会执行相应的逻辑。它还实现了 BeanFactoryAware 接口，用于在运行时获取 BeanFactory，这样可以在需要时从容器中获取其他 bean。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在 postProcessPropertyValues 方法中，它首先检查 bean 中的每个字段是否带有 <span class="doctag">@Value</span> 注解，如果有，则解析注解中的值并进行注入。然后它再次遍历字段，检查是否带有 <span class="doctag">@Autowired</span> 注解，如果有，则根据字段类型获取相应的依赖 bean，并进行注入。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;总的来说，AutowiredAnnotationBeanPostProcessor 的作用是完成对带有 <span class="doctag">@Autowired</span> 和 <span class="doctag">@Value</span> 注解的属性进行自动依赖注入的操作。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = (ConfigurableListableBeanFactory) beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成依赖注入操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MutablePropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(MutablePropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Bean的Class对象和该类中所有声明的字段fields</span></span><br><span class="line">        Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理@Value注解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 2. 检查当前字段是否带有@Value注解</span></span><br><span class="line">            <span class="type">Value</span> <span class="variable">valueAnnotation</span> <span class="operator">=</span> field.getAnnotation(Value.class);</span><br><span class="line">            <span class="keyword">if</span> (valueAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 如果字段带有@Value注解，获取value属性，这是要注入到字段中的值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> valueAnnotation.value();</span><br><span class="line">                <span class="comment">// 4. 使用beanFactory的resolveEmbeddedValue方法来解析字符串中的占位符，获得实际的属性值</span></span><br><span class="line">                value = beanFactory.resolveEmbeddedValue(value);</span><br><span class="line">                <span class="comment">/* 5. 工具类</span></span><br><span class="line"><span class="comment">                    接收三个参数：</span></span><br><span class="line"><span class="comment">                        bean:要设置值的Bean对象</span></span><br><span class="line"><span class="comment">                        fieldName:Bean对象中字段的名称</span></span><br><span class="line"><span class="comment">                        value:要设置到字段中的值</span></span><br><span class="line"><span class="comment">                    通过反射机制获取Bean对象中指定字段的Field对象</span></span><br><span class="line"><span class="comment">                    然后调用set方法设置字段的值</span></span><br><span class="line"><span class="comment">                    最后返回设置后的Bean对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    总的来说，就是将解析后的值（value）注入到指定 Bean（bean）的指定字段（field.getName()）中</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                BeanUtil.setFieldValue(bean, field.getName(), value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理@Autowire注解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 2. 检查当前字段是否带有@Autowired注解</span></span><br><span class="line">            <span class="type">Autowired</span> <span class="variable">autowiredAnnotation</span> <span class="operator">=</span> field.getAnnotation(Autowired.class);</span><br><span class="line">            <span class="keyword">if</span> (autowiredAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 如果带有@Autowired注解，接着获取字段的类型fieldType</span></span><br><span class="line">                Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">                <span class="comment">// 4. 该变量用于存储依赖Bean的名称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">dependentBeanName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 5. 获取字段上的@Qualifier注解</span></span><br><span class="line">                <span class="type">Qualifier</span> <span class="variable">qualifierAnnotation</span> <span class="operator">=</span> field.getAnnotation(Qualifier.class);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">dependentBean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 6.1 如果存在@Qualifier注解的话，说明开发者指定了一个特定的Bean名称来注入</span></span><br><span class="line">                <span class="keyword">if</span> (qualifierAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将@Qualifier注解的值赋给dependentBeanName</span></span><br><span class="line">                    dependentBeanName = qualifierAnnotation.value();</span><br><span class="line">                    <span class="comment">// 使用getBean(dependentBeanName, fieldType)方式获取特定Bean实例</span></span><br><span class="line">                    dependentBean = beanFactory.getBean(dependentBeanName, fieldType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 6.2 如果不存在，使用getBean(fieldType)方式获取Bean实例</span></span><br><span class="line">                    dependentBean = beanFactory.getBean(fieldType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 7 将解析后的值注入到指定字段中</span></span><br><span class="line">                BeanUtil.setFieldValue(bean, field.getName(), dependentBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回处理后的MutablePropertyValues对象，该对象包含了所有属性值的设置</span></span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-Autowired操作逻辑"><a href="#添加-Autowired操作逻辑" class="headerlink" title="添加@Autowired操作逻辑"></a>添加@Autowired操作逻辑</h3><p>一、<code>BeanFactory</code>接口，<code>DefaultListableBeanFactory</code>类，<code>AbstractApplicationContext</code>抽象类，多实现了一个 <code>getBeanOfType()</code>的方法，根据类型获取Bean。、</p>
<p>二、<code>@Autowired</code>注解、<code>@Qualifier</code>注解用于实现依赖注入</p>
<ul>
<li><code>@Autowired</code>注解：可以用于类的成员变量、构造函数、设置方法上，用于自动注入依赖。当Spring容器启动时，它会自动查找相应的Bean，并注入到标注了 <code>@Autowired</code>的字段或方法中。默认情况下，Spring按照类型（Type）进行匹配，找到合适的Bean进行注入。</li>
<li><code>@Qualifier</code>注解：当Spring上下文中存在多个相同类型的Bean时，使用 <code>@Autowired</code>进行注入可能会出现无法确定注入哪一个Bean的情况。此时可以使用 <code>@Qualifier</code>注解来指定注入哪一个Bean。<code>@Qualifier</code>需要与 <code>@Autowired</code>一起使用，用于指定Bean的名称。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userServiceImp&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(<span class="meta">@Qualifier(&quot;userServiceImpl&quot;)</span> UserService userService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、<code>AutowiredAnnotationBeanPostProcessor</code>类中加入对这两个注解解析的逻辑（见上面的代码）</p>
<h2 id="3-占位符解析"><a href="#3-占位符解析" class="headerlink" title="3. 占位符解析"></a>3. 占位符解析</h2><p>主要分为两部分</p>
<h3 id="3-1-解析xml文件中的占位符"><a href="#3-1-解析xml文件中的占位符" class="headerlink" title="3.1 解析xml文件中的占位符"></a>3.1 解析xml文件中的占位符</h3><p><code>refresh()</code>方法中自动执行 <code>BeanFactoryPostProcessor</code>子实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyPlaceholderConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀</span></span><br><span class="line">    <span class="comment">// 后缀</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String location)</span> &#123;<span class="built_in">this</span>.location = location;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 加载Property文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> loadProperties();</span><br><span class="line">        <span class="comment">// 解析xml文件中的占位符</span></span><br><span class="line">        processProperties(beanFactory, properties);</span><br><span class="line">        <span class="comment">// 解析@Value注解中的占位符，将其加到BeanFactory的解析器集合中</span></span><br><span class="line">        <span class="type">StringValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaceholderResolvingStringValueResolver</span>(properties);</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(valueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PlaceholderResolvingStringValueResolver</span> <span class="keyword">implements</span> <span class="title class_">StringValueResolver</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Properties properties;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PlaceholderResolvingStringValueResolver</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="keyword">return</span> PropertyPlaceholderConfigurer.<span class="built_in">this</span>.resolvePlaceholder(strVal, properties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-解析-Value注解中的占位符"><a href="#3-2-解析-Value注解中的占位符" class="headerlink" title="3.2 解析@Value注解中的占位符"></a>3.2 解析@Value注解中的占位符</h3><p>注意，<code>refresh()</code>方法中，<code>BeanFactoryPostProcessor</code>是自动执行的，<code>BeanPostProcessor</code>是在实例化Bean时在 <code>getBean()</code>方法的 <code>doCreateBean()</code>方法中自动执行的</p>
<p>基于第二部分，中间穿插了一个解析嵌入值的方法</p>
<p>执行流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware</span></span><br><span class="line"><span class="comment">// @Override postProcessPropertyValues</span></span><br><span class="line">value = beanFactory.resolveEmbeddedValue(value);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">HierarchicalBeanFactory</span>, SingletonBeanRegistry &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 添加嵌入值解析器</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addEmbeddedValueResolver</span><span class="params">(StringValueResolver valueResolver)</span>;</span><br><span class="line">    <span class="comment">// 解析嵌入值</span></span><br><span class="line">	String <span class="title function_">resolveEmbeddedValue</span><span class="params">(String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历嵌入值解析器，调用解析方法 <code>resolveStringValue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory</span></span><br><span class="line"><span class="comment">// 存储解析器的容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;StringValueResolver&gt; embeddedValueResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringValueResolver&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEmbeddedValueResolver</span><span class="params">(StringValueResolver valueResolver)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.embeddedValueResolvers.add(valueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">resolveEmbeddedValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> value;</span><br><span class="line">	<span class="keyword">for</span> (StringValueResolver resolver : <span class="built_in">this</span>.embeddedValueResolvers) &#123;</span><br><span class="line">		result = resolver.resolveStringValue(result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StringValueResolver</span> &#123;</span><br><span class="line">    String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>resolveStringValue()</code>方法就调用到了 <code>PropertyPlaceholderConfigurer</code>中对占位符的处理</p>
<h3 id="3-3-适配器模式"><a href="#3-3-适配器模式" class="headerlink" title="3.3 适配器模式"></a>3.3 适配器模式</h3><p>通过内部类的方式将两个不同的接口的子实现类结合到了一起。</p>
<p><code>PlaceholderResolvingStringValueResolver</code>是 <code>PropertyPlaceholderConfigurer</code>的内部类，实现了额外的标记接口，调用外部类中的方法作为自己内部对接口的重写方法。</p>
<h1 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h1><p>第一次提交改动了一个东西</p>
<p><code>DefaultAdvisorAutoProxyCreator</code>和 <code>AbstractAutowireCapableBeanFactory</code></p>
<p>以前是直接在 <code>creatBean()</code>方法中单开了一条逻辑处理动态代理，没有注入属性那一步操作。</p>
<p>现在是将对动态代理的操作插入到了 <code>initializeBean()</code>方法的 <code>BeanPostProcessor</code>的前置和后置处理中，每一个后处理器都会被应用到每一个bean上，即每个bean都会进入动态代理的判断，判断该bean是否符合切点表达式，如果符合，则返回代理对象，如果不符合，则返回原对象。通过 <code>BeanPostProcessor</code>真正融入生命周期。</p>
<p>随后进一步完善了Bean的生命周期，增加了前置处理和后置处理的操作</p>
<p><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/image-20240506171655743.png" alt="image-20240506171655743"></p>
<h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h2><p>Bean的生命周期是一个从创建到销毁的过程，此类中定义的Bean的生命周期如下：</p>
<ol>
<li><p><strong>前置处理</strong>（Pre-Instantiation）<br>在Bean实际被创建之前，<code>resolveBeforeInstantiation</code>方法允许应用 <code>BeanPostProcessors</code>进行预处理，这可能会返回一个完全不同的对象。如果这个方法返回一个代理或增强过的对象，那么后续的标准实例化过程可能会被跳过。</p>
</li>
<li><p><strong>实例化</strong>（Instantiation）<br>首先，Spring容器通过 <code>BeanDefinition</code>（包含类的全名、作用域信息、属性描述等）来创建Bean的实例。实例化的方式可能通过构造器实例化、工厂方法实例化或其他方式。在 <code>AbstractAutowireCapableBeanFactory</code>中，实例化策略由 <code>instantiationStrategy</code>决定，并通过 <code>createBeanInstance</code>方法具体执行。</p>
</li>
<li><p><strong>后置处理</strong>（Post-Instantiation）<br>通过 <code>applyBeanPostProcessorsAfterInstantiation</code>方法可以进行一些后处理。如果此步骤中任何处理器返回false，将不会继续后续的属性填充。</p>
</li>
<li><p><strong>修改属性值</strong></p>
<p>例如将占位符修改为真实值</p>
</li>
<li><p><strong>属性填充</strong>（Populate Properties）<br>如果 <code>postProcessAfterInstantiation</code>方法返回 <code>true</code>（默认行为），Spring将继续进行属性注入。这包括通过反射技术设置Bean的属性值。<code>applyPropertyValues</code>方法会将 <code>BeanDefinition</code>中定义的属性值应用到新创建的对象上。</p>
</li>
<li><p><strong>初始化</strong>（Initialization）<br>初始化是一个多步骤的过程，包括： a.调用 <code>BeanPostProcessors</code>的前置方法。 b.如果Bean实现了 <code>InitializingBean</code>接口，则调用其 <code>afterPropertiesSet</code>方法。 c.如果在 <code>BeanDefinition</code>中指定了自定义的初始化方法，该方法也将被调用。 d.调用 <code>BeanPostProcessors</code>的后置方法。</p>
</li>
<li><p><strong>使用</strong>（Usage）<br>这时，Bean已完全准备好，可以被应用程序使用。在这个阶段，Bean处于完全激活状态，可以响应对其方法的调用。</p>
</li>
<li><p><strong>销毁</strong>（Destruction）<br>对于单例作用域的Bean，当Spring容器关闭时，容器将调用注册的 <code>DisposableBean</code>的 <code>destroy</code>方法以及自定义的销毁方法。这是清理资源和执行必要的清除任务的好机会。</p>
</li>
</ol>
<p>在整个生命周期中，Spring通过使用多种钩子和操作提供了极大的灵活性，使得可以在创建和管理Bean时插入自定义逻辑和处理流程。<code>AbstractAutowireCapableBeanFactory</code>是实现这一生命周期复杂管理的核心组件之一，它通过多个扩展点允许开发者定制和优化Bean的行为和生命周期。</p>
<h2 id="2-前置处理"><a href="#2-前置处理" class="headerlink" title="2. 前置处理"></a>2. 前置处理</h2><p>前置处理指的是在Bean实例化之前的处理。在这个阶段，可以通过Bean的后置处理器（BeanPostProcessor）的 <code>postProcessBeforeInstantiation</code>方法来进行操作。这个方法允许开发者在Bean的实际实例化之前修改Bean的定义或提供代理实现。这个处理阶段的主要作用和优势包括：</p>
<ul>
<li><strong>修改或替换Bean定义</strong>：<ul>
<li>开发者可以在Bean实例化前修改Bean的定义或配置，如改变Bean的作用域、调整Bean的属性等。</li>
<li>可以完全替换掉原来的Bean定义，返回一个全新的代理或其他对象实例，从而影响Spring容器最终所创建的Bean对象。</li>
</ul>
</li>
<li><strong>提前介入Bean的创建过程</strong>：<ul>
<li>允许开发者在Bean的任何属性被设置前介入，提供一种方式来执行一些预处理操作，比如检查或准备一些必要的资源或条件。</li>
<li>可以用于实现一些基于条件的逻辑，例如根据特定的配置信息或环境变量决定是否或如何创建某个Bean。</li>
</ul>
</li>
<li><strong>提供代理实现</strong>：<ul>
<li>常用于AOP（面向切面编程）中，允许在Bean实际创建之前插入代理，从而为Bean提供额外的功能，如安全检查、事务管理、日志记录等。</li>
<li>这种代理实现通常涉及创建一个实现了原Bean接口的代理类，这个代理类在调用原始Bean的方法前后可以执行额外的操作。</li>
</ul>
</li>
<li><strong>优化性能</strong>：<ul>
<li>通过提前处理或替换Bean，可以避免不必要的Bean实例化，特别是在Bean的创建成本很高或者需要根据条件判断后才决定创建的情况下。</li>
<li>这可以显著提高应用启动和运行的效率，尤其是在大型或复杂的Spring应用中。</li>
</ul>
</li>
<li><strong>灵活性和可扩展性</strong>：<ul>
<li>提供了一种机制，通过它开发者可以根据需要灵活地控制和扩展Bean的创建过程，使得应用能够更好地适应不断变化的需求和环境。</li>
</ul>
</li>
</ul>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;someBean&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 修改Bean定义或返回代理对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null，容器会继续使用默认的实例化策略，返回bean，则跳过后面的所有生命周期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-后置处理"><a href="#3-后置处理" class="headerlink" title="3. 后置处理"></a>3. 后置处理</h2><p>后置处理指的是在Bean实例化之后的处理。这个阶段也是通过实现BeanPostProcessor接口来进行，具体是通过 <code>postProcessAfterInstantiation</code>方法。在这个方法中，可以对Bean实例进行额外的配置或初始化。这个方法在Bean的属性被设置之后调用，可以用来进行一些依赖注入之外的自定义初始化逻辑。这个阶段的主要作用和优点包括：</p>
<ul>
<li><strong>自定义修改或检查Bean实例</strong>：<ul>
<li>在Bean属性设置之前，可以检查或修改Bean实例。这允许开发者对Bean实例执行一些状态或数据的验证，确保Bean在属性设置前已经满足某些条件。</li>
<li>可以用来设置一些不通过Spring配置注入的属性或依赖。</li>
</ul>
</li>
<li><strong>条件阻止属性注入</strong>：<ul>
<li>通过返回值可以控制是否允许Spring继续对Bean进行属性注入。如果 <code>postProcessAfterInstantiation</code>方法返回 <code>false</code>，则Spring容器将不会对该Bean进行后续的属性设置操作，这可以用于条件化地阻止自动装配。</li>
</ul>
</li>
<li><strong>增强Bean的功能</strong>：<ul>
<li>可以在Bean完全配置前增加一些功能，比如对Bean实现一些自动化的配置检测或初始化一些在构造函数中无法完成的复杂成员。</li>
</ul>
</li>
<li><strong>保证Bean的完整性和一致性</strong>：<ul>
<li>在Bean的属性被注入前进行操作，可以确保当Bean的属性被注入时，Bean处于一个预期的状态，这对于保证Bean的一致性和完整性至关重要。</li>
</ul>
</li>
</ul>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> SomeClass) &#123;</span><br><span class="line">            <span class="comment">// 进行一些初始化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true表示容器应继续正常处理，返回false表示阻止属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="1-基础类关系"><a href="#1-基础类关系" class="headerlink" title="1. 基础类关系"></a>1. 基础类关系</h2><p><code>ConversionService</code>接口，顶层接口，定义转换方法和是否能转换方法</p>
<p><code>Converter</code>接口，一对一转换器接口，用于开发者自己实现</p>
<p><code>ConverterFactory</code>接口，一对多转换器接口，开发者自己实现</p>
<p><code>GenericConverter</code>接口，通用类型转换器接口</p>
<p><code>ConverterAdapter</code>内部类 implements <code>GenericConverter</code>，聚合了 <code>Converter</code></p>
<p><code>ConverterFactoryAdapter</code>内部类 implements <code>GenericConverter</code>，聚合了 <code>ConverterFactory</code></p>
<p><code>ConverterRedistry</code>接口，注册接口，定义了写向转换器注册表中添加类型转换器的三个模板方法</p>
<p><code>GenericConverterService</code>类 implements <code>ConversionService</code>,<code>ConverterRedistry</code>，类型转换中心，用于<strong>管理和执行</strong>从一个数据类型到另一个数据类型的转换</p>
<p><code>StringToNumberConverterFactory</code>类，Spring内嵌的一个 <code>ConverterFactory</code>子实现类</p>
<p><code>DefaultConversionService</code>类，预定义了一个转换器 <code>StringToNumberConverterFactory</code>，通过默认转换器来简化常见的数据转换任务，允许开发者轻松扩展或定制转换逻辑，以适应不同的应用场景，提高了开发效率和代码的可维护性。</p>
<h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h2><h3 id="2-1-适配器模式"><a href="#2-1-适配器模式" class="headerlink" title="2.1 适配器模式"></a>2.1 适配器模式</h3><ul>
<li><strong>使用场景</strong>: 用于将一个类的接口转换成客户期望的另一个接口。<code>Converter</code>和 <code>ConverterFactory</code>通过 <code>ConverterAdapter</code>和 <code>ConverterFactoryAdapter</code>被适配为 <code>GenericConverter</code>，从而可以统一处理。</li>
<li>角色分配:<ul>
<li><strong><code>Converter</code>和 <code>ConverterFactory</code></strong>: 这些接口定义了简单的转换逻辑和基于类型的工厂转换逻辑。</li>
<li><strong><code>ConverterAdapter</code>和 <code>ConverterFactoryAdapter</code></strong>: 作为适配器，它们实现了 <code>GenericConverter</code>接口，允许 <code>Converter</code>和 <code>ConverterFactory</code>在 <code>GenericConversionService</code>中统一管理。</li>
</ul>
</li>
</ul>
<h3 id="2-2-策略模式"><a href="#2-2-策略模式" class="headerlink" title="2.2 策略模式"></a>2.2 策略模式</h3><ul>
<li><strong>使用场景</strong>: 策略模式用于定义一系列的算法，把它们一个个封装起来，并使它们可相互替换。此模式让算法的变化独立于使用算法的客户。</li>
<li>角色分配:<ul>
<li><strong><code>GenericConverter</code></strong>: 充当具体策略角色，定义了不同的类型转换逻辑。</li>
<li><strong><code>GenericConversionService</code></strong>: 充当上下文角色，使用不同的 <code>GenericConverter</code>策略来完成类型转换的任务。</li>
</ul>
</li>
</ul>
<h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p>工厂模式、单例模式、模板方法模式这些就不多说了</p>
<h2 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h2><p><code>BeanFactory接口</code></p>
<p><code>ConfigurableBeanFactory接口</code></p>
<p><code>AbstractBeanFactory抽象类</code></p>
<p><code>AbstractAutowireCapableBeanFactory抽象类</code></p>
<p>如何嵌入Bean的生命周期？</p>
<p>主要可以分为四部分：</p>
<ul>
<li>转换器和类型转换中心本身</li>
<li>注入</li>
<li>设置</li>
<li>使用</li>
</ul>
<p>xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主要是注入这个，剩下是自定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;converters&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.bean.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;produceDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2021-01-01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converters&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.common.ConvertersFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-转换器和类型转换中心本身"><a href="#3-1-转换器和类型转换中心本身" class="headerlink" title="3.1 转换器和类型转换中心本身"></a>3.1 转换器和类型转换中心本身</h3><p><code>GenericConversionService</code>类型转换中心使用适配器模式整合两种不同的转换器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericConversionService</span> <span class="keyword">implements</span> <span class="title class_">ConversionService</span>, ConverterRegistry &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;转换器映射表</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;键：GenericConverter.ConvertiblePair 类型，表示可转换的源类型与目标类型的组合</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;值：GenericConverter 类型，表示对应的类型转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;GenericConverter.ConvertiblePair, GenericConverter&gt; converters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否存在源类型到目标类型的转换器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">        <span class="keyword">return</span> converter != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行类型转换</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定源对象的类类型</span></span><br><span class="line">        Class&lt;?&gt; sourceType = source.getClass();</span><br><span class="line">        <span class="comment">// 将基本数据类型转换为其对应的包装类类型</span></span><br><span class="line">        targetType = (Class&lt;T&gt;) BasicType.wrap(targetType);</span><br><span class="line">        <span class="comment">// 找到合适的转换器</span></span><br><span class="line">        <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">        <span class="comment">// 调用其convert方法转换对象</span></span><br><span class="line">        <span class="keyword">return</span> (T) converter.convert(source, sourceType, targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---三个添加转换器的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个简单的转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converter 一个实现了 Converter 接口的类型转换器实例，用于执行单个类型到类型的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过getRequiredTypeInfo方法获取转换器的源类型和目标类型信息</span></span><br><span class="line">        GenericConverter.<span class="type">ConvertiblePair</span> <span class="variable">typeInfo</span> <span class="operator">=</span> getRequiredTypeInfo(converter);</span><br><span class="line">        <span class="comment">// 创建一个ConverterAdapter实例并注册到转换器映射中</span></span><br><span class="line">        <span class="type">ConverterAdapter</span> <span class="variable">converterAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConverterAdapter</span>(typeInfo, converter);</span><br><span class="line">        <span class="keyword">for</span> (GenericConverter.ConvertiblePair convertibleType : converterAdapter.getConvertibleTypes()) &#123;</span><br><span class="line">            converters.put(convertibleType, converterAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个转换器工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterFactory 一个实现了 ConverterFactory 接口的类型转换器工厂实例，用于动态获取类型到类型的转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; converterFactory)</span> &#123;</span><br><span class="line">        GenericConverter.<span class="type">ConvertiblePair</span> <span class="variable">typeInfo</span> <span class="operator">=</span> getRequiredTypeInfo(converterFactory);</span><br><span class="line">        <span class="type">ConverterFactoryAdapter</span> <span class="variable">converterFactoryAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConverterFactoryAdapter</span>(typeInfo, converterFactory);</span><br><span class="line">        <span class="keyword">for</span> (GenericConverter.ConvertiblePair convertibleType : converterFactoryAdapter.getConvertibleTypes()) &#123;</span><br><span class="line">            converters.put(convertibleType, converterFactoryAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用类型转换器</span></span><br><span class="line"><span class="comment">     * 重载的addConverter方法直接添加一个GenericConverter到映射中，这种转换器可以处理多种类型的转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converter 一个实现了 GenericConverter 接口的通用类型转换器实例，用于执行复杂的、特定场景下的类型转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(GenericConverter converter)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (GenericConverter.ConvertiblePair convertibleType : converter.getConvertibleTypes()) &#123;</span><br><span class="line">            converters.put(convertibleType, converter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 用大量的反射，以获取GenericConverter.ConvertiblePair作为Map的键</span></span><br><span class="line">    <span class="comment">// 通过反射获取对象实现的泛型接口的实际类型参数，以确定源类型和目标类型</span></span><br><span class="line">    <span class="keyword">private</span> GenericConverter.ConvertiblePair <span class="title function_">getRequiredTypeInfo</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保护方法</span></span><br><span class="line">    <span class="keyword">protected</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回给定类的类层次结构列表，包括它的所有超类。</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; getClassHierarchy(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 适配Converter实例，使其可以注册到通用的类型转换服务中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConverterAdapter</span> <span class="keyword">implements</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConvertiblePair typeInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, Object&gt; converter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ConverterAdapter</span><span class="params">(ConvertiblePair typeInfo, Converter&lt;?, ?&gt; converter)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.typeInfo = typeInfo;</span><br><span class="line">            <span class="built_in">this</span>.converter = (Converter&lt;Object, Object&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(typeInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(Object source, Class sourceType, Class targetType)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> converter.convert(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 适配ConverterFactory实例，使其可以注册到通用的类型转换服务中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConverterFactoryAdapter</span> <span class="keyword">implements</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConvertiblePair typeInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConverterFactory&lt;Object, Object&gt; converterFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ConverterFactoryAdapter</span><span class="params">(ConvertiblePair typeInfo, ConverterFactory&lt;?, ?&gt; converterFactory)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.typeInfo = typeInfo;</span><br><span class="line">            <span class="built_in">this</span>.converterFactory = (ConverterFactory&lt;Object, Object&gt;) converterFactory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(typeInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(Object source, Class sourceType, Class targetType)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> converterFactory.getConverter(targetType).convert(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;span style=&quot;color:red&quot;&gt;</code>ConversionService是类型转换体系的核心接口，通过内部类适配器模式将以上三种类型转换器整合到一起，GenericConversionService是其实现类，DefaultConversionService在GenericConversionService的基础上添加内置转换器。</p>
<h3 id="3-2-注入类型转换中心"><a href="#3-2-注入类型转换中心" class="headerlink" title="3.2 注入类型转换中心"></a>3.2 注入类型转换中心</h3><p>首先，<code>ConversionServiceFactoryBean</code>有两个成员变量，其中一个是 <code>GenericConversionService</code>类型转换中心，<code>ConversionServiceFactoryBean</code>将所有的转换器都注册进类型转换中心当中，然后将类型转换中心作为bean注入到Spring容器当中。<code>&lt;span style=&quot;color:red&quot;&gt;</code><em><strong>FactoryBean工厂注入方式</strong></em> <strong>发挥了大作用，工厂方式允许在创建 Bean 实例时进行更复杂的逻辑处理，例如这里就通过该方式为Spring的GenericConversionService类型转换中心注入多个类型转换器，从而提供更大的灵活性和定制性</strong></p>
<h3 id="3-3-设置类型转换中心"><a href="#3-3-设置类型转换中心" class="headerlink" title="3.3 设置类型转换中心"></a>3.3 设置类型转换中心</h3><p><code>AbstractApplicationContext</code>的 <code>finishBeanFactoryInitialization()</code>方法中，给 <code>AbstractBeanFactory</code>设置类型转换中心作为成员变量：先根据 <code>getBean()</code>方法获取到类型转换中心，然后调用 <code>beanFactory.setConversionService()</code>方法类型转换中心设置上去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#refresh()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//设置类型转换中心</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">conversionService</span> <span class="operator">=</span> beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (conversionService <span class="keyword">instanceof</span> ConversionService) &#123;</span><br><span class="line">            beanFactory.setConversionService((ConversionService) conversionService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提前实例化单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-使用类型转换中心中的转换器"><a href="#3-4-使用类型转换中心中的转换器" class="headerlink" title="3.4 使用类型转换中心中的转换器"></a>3.4 使用类型转换中心中的转换器</h3><p>然后就是使用类型转换中心的转换器了</p>
<p>类型转换的时机有两个：</p>
<ul>
<li>为bean填充属性时，见AbstractAutowireCapableBeanFactory#applyPropertyValues</li>
<li>处理@Value注解时，见AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</li>
</ul>
<p>以第一个为例，<code>AbstractAutowireCapableBeanFactory#doCreaateBean()</code>方法中在为Bean填充属性时，执行类型转换操作，注解和这个差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applyPropertyValues</span></span><br><span class="line"><span class="comment">// 如果不是，则检查是否需要进行类型转换</span></span><br><span class="line"><span class="comment">// 获取value的实际类型</span></span><br><span class="line">Class&lt;?&gt; sourceType = value.getClass();</span><br><span class="line"><span class="comment">// 获取目标bean对应的类型，自动找出对应bean类中该成员变量的类型，设为目标类型，然后进行转换操作</span></span><br><span class="line">Class&lt;?&gt; targetType = (Class&lt;?&gt;) TypeUtil.getFieldType(bean.getClass(), name);</span><br><span class="line"><span class="comment">// 获取类型转换服务</span></span><br><span class="line"><span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> getConversionService();</span><br><span class="line"><span class="comment">// 检查是否可以从sourceType转换到targetType</span></span><br><span class="line"><span class="keyword">if</span> (conversionService != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (conversionService.canConvert(sourceType, targetType)) &#123;</span><br><span class="line">        <span class="comment">// 如果可以，执行转换</span></span><br><span class="line">        value = conversionService.convert(value, targetType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-开发者使用"><a href="#3-5-开发者使用" class="headerlink" title="3.5 开发者使用"></a>3.5 开发者使用</h3><p>一种是使用Spring默认的，见3.4</p>
<p>另一种就是开发者自定义了，这里举个字符串和日期类型的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToLocalDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, LocalDate&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringToLocalDateConverter</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalDate <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(source, DATE_TIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertersFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Set&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并返回转换器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;?&gt; getObject() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HashSet&lt;Object&gt; converters = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringToLocalDateConverter</span> <span class="variable">stringToLocalDateConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringToLocalDateConverter</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        converters.add(stringToLocalDateConverter);</span><br><span class="line">        <span class="keyword">return</span> converters;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConversionService</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:type-conversion-second-part.xml&quot;</span>);</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;car&quot;</span>, Car.class);</span><br><span class="line">    assertThat(car.getPrice()).isEqualTo(<span class="number">1000000</span>);</span><br><span class="line">    assertThat(car.getProduceDate()).isEqualTo(LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><h3 id="4-1-收获"><a href="#4-1-收获" class="headerlink" title="4.1 收获"></a>4.1 收获</h3><ul>
<li>对适配器模式、策略模式的应用</li>
<li>对 <code>FactoryBean</code>的使用</li>
</ul>
<h3 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h3><ul>
<li><p>前端向后端传递的通常是json格式字符串，需要类型转换</p>
</li>
<li><p>后端开发者的自定义类型转换器</p>
<ul>
<li><p><strong>自定义数据类型</strong></p>
<p>当你的应用需要处理特定业务逻辑的自定义数据类型时，如货币、复杂的时间周期、或是特殊的业务标识符等，标准的类型转换器可能不会提供这些类型的转换支持。在这种情况下，开发者需要实现并注册自定义转换器来确保数据可以正确地从一种格式转换为另一种格式。</p>
</li>
<li><p><strong>第三方类库模型</strong></p>
<p>如果你的应用集成了第三方服务或类库，这些外部系统可能使用不同的数据类型或格式。例如，如果一个外部库返回的日期格式是字符串，而你希望在你的系统中使用 <code>java.time.LocalDate</code>，你可能需要创建一个转换器来处理这种转换。</p>
</li>
<li><p>数据库枚举类型处理</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-注意"><a href="#4-3-注意" class="headerlink" title="4.3 注意"></a>4.3 注意</h3><p>“类型转换实际开发中开发者手动转换可能用不到，因为后端向前端传递数据传的就是字符串，没必要再转换。”这种想法不可以有！</p>
<p>显式进行转换可以提供更好的控制、一致性和灵活性！不然当你要对 <code>getBean()</code>到的数据做额外处理时，还得再次手动转换，做不到一致性。</p>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p><code>&lt;span style=&quot;color:blue&quot;&gt;</code><strong>注意：在设计层面上，循环依赖通常是不良设计的标志。可以通过重新设计类的职责、引入中介者模式、使用事件驱动方法或将共同功能抽象到另一个类中来解决循环依赖问题。</strong></p>
<p>循环依赖发生在两个或多个 Bean 互相依赖，形成一个循环链，导致 Bean 无法正常初始化。例如：</p>
<ul>
<li>Bean A 依赖于 Bean B</li>
<li>Bean B 又依赖于 Bean A</li>
</ul>
<p>Spring使用三级缓存来处理循环依赖，一般二级缓存就够处理循环依赖了，但是面对代理对象，二级缓存中存储的是实例化bean，实际需要的bean是代理bean。三级缓存就是为了解决代理对象的循环依赖问题。</p>
<h2 id="1-解决循环依赖的前置条件"><a href="#1-解决循环依赖的前置条件" class="headerlink" title="1. 解决循环依赖的前置条件"></a>1. 解决循环依赖的前置条件</h2><ul>
<li>Bean 必须是单例范围（<code>singleton</code>）。</li>
<li>依赖注入的方式不能全是构造器注入的方式</li>
</ul>
<h2 id="2-用到的类"><a href="#2-用到的类" class="headerlink" title="2. 用到的类"></a>2. 用到的类</h2><p>一、</p>
<p><code>InstantiationAwareBeanPostProcessor</code>接口（创建代理类的类实现的接口），多了个 <code>getEarlyBeanReference()</code>方法，用于提前暴露bean。</p>
<p><code>DefaultAdvisorAutoProxyCreator</code>类（创建代理类的类），实现了上面那个方法，</p>
<p>该类还是创建代理对象的类，只是多了一个关于处理提前创建好的代理对象的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultAdvisorAutoProxyCreator implements InstantiationAwareBeanPostProcessor, BeanFactoryAware</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储被提前创建的代理对象</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是正常流程执行AOP动态代理</span></span><br><span class="line"><span class="comment">// 初始化后置处理（Spring中，AOP代理在生命周期的最后阶段执行）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!earlyProxyReferences.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是提前创建代理对象</span></span><br><span class="line"><span class="comment">// 得到早期曝光对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    earlyProxyReferences.add(beanName);</span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象（wrap:包裹，计算机中指在原始对象的基础上创建一个代理对象）</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 内部执行创建代理对象的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、</p>
<p><code>ObjectFactory</code>接口，<code>getObject()</code>方法</p>
<p>唯一一个实现在 <code>addSinglletonFactory()</code>方法中做参数</p>
<p>三、</p>
<p>单例池（一级缓存）</p>
<p>早期曝光对象（二级缓存）</p>
<p>早期曝光对象工厂（三级缓存）</p>
<p><code>DefaultSingletonBeanRegistry</code>类（默认单例注册表，bean容器及对其的基本操作都在这里）</p>
<p><code>getSingleton()</code>方法：</p>
<ol>
<li><strong>尝试获取完全初始化的 Bean</strong>： 在获取 Bean 的时候，首先会从一级缓存中 <code>singletonObjects</code> 获取。如果有完全初始化的 Bean，则直接返回。</li>
<li><strong>尝试获取早期引用的 Bean</strong>： 如果一级缓存中没有，则从二级缓存 <code>earlySingletonObjects</code> 获取。如果存在早期引用，则直接返回。</li>
<li><strong>从三级缓存创建早期引用</strong>： 如果二级缓存也没有，Spring 会从三级缓存 <code>singletonFactories</code> 获取对象工厂 <code>ObjectFactory</code>，通过它来创建早期引用，然后将创建的早期引用放入二级缓存 <code>earlySingletonObjects</code>，并移除三级缓存中的工厂。</li>
<li><strong>创建 Bean</strong>： 如果以上都没有找到 Bean，Spring 会尝试实例化该 Bean，在实例化的过程中可能会递归地调用其他 Bean。如果过程中遇到了循环依赖的问题，则使用二级缓存 <code>earlySingletonObjects</code> 中的早期引用来解决。</li>
<li><strong>后处理器和代理</strong>： 如果 Bean 实例化过程中使用了 Bean 后处理器，处理器可能会将 Bean 转换成代理对象。代理对象通常会放入三级缓存，以在循环依赖情况下获取代理对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry 默认单例注册表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例池（一级缓存）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 早期曝光对象（二级缓存）</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 早期曝光对象工厂（三级缓存）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        singletonObject = earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                <span class="comment">// 从三级缓存放进二级缓存</span></span><br><span class="line">                earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、</p>
<p><code>AbstractAutowireCapableBeanFactory</code>抽象类</p>
<p>生命周期中插入了提前曝光对象的逻辑（在 <code>doCreateBean()</code>方法当中），变化的总共有三步：</p>
<p>第一步是在bean实例化后立马创建对象工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧挨着实例化之后执行 创建早期曝光对象工厂并添加到三级缓存中</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">finalBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="comment">// 这一步会提前调用AOP动态代理</span></span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, beanDefinition, finalBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步是填充属性中调用的 <code>getSingleton()</code>，这一步在上面有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyPropertyValues # getBean # getSingleton</span><br></pre></td></tr></table></figure>

<p>第三步是添加bean到单例池中时，直接添加二级缓存中的bean单例，然后将二级缓存中的该bean移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doCreatBean()</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 如果有代理对象，此处获取代理对象</span></span><br><span class="line">    exposedObject = getSingleton(beanName);</span><br><span class="line">    addSingleton(beanName, exposedObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">    singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    earlySingletonObjects.remove(beanName);</span><br><span class="line">    singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-简单示例-执行流程"><a href="#3-简单示例-执行流程" class="headerlink" title="3. 简单示例&amp;执行流程"></a>3. 简单示例&amp;执行流程</h2><p>假设类A、B相互依赖</p>
<p>**A.1. **A实例化后立马创建自己的早期曝光对象工厂并添加到三级缓存中</p>
<p>如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象（通过 <code>getEarlyBeanReference()</code>方法实现）</p>
<p>**A.2. **A要填充属性B</p>
<p>**B.1. **B也实例化后立马创建自己的早期曝光对象工厂并添加到三级缓存中</p>
<p>**B.2. **B要填充属性A，调用 <code>applyPropertyValues</code> # <code>getBean</code> # <code>getSingleton</code>，通过 <code>getSingleton()</code>方法，获得属性A</p>
<p>**B.3. **B成功填充属性，完成B的生命周期，将二级缓存中的B存储到单例池中。</p>
<p>**A.3. **然后A获得完整的B，完成A的生命周期，将二级缓存中的A存储到单例池中。</p>
<p>至此循环依赖处理完成。</p>
<blockquote>
<p>当循环依赖遇上JDK动态代理，真是酣畅淋漓的一场debug qwq</p>
<p>注意：JDK动态代理一切基于接口，原始类和代理类是基于同一个接口的不同子实现类，二者之间的转换要通过接口来实现，倘若二者直接相互转换，便会出现报错。</p>
</blockquote>
<h2 id="4-不能解决的循环依赖"><a href="#4-不能解决的循环依赖" class="headerlink" title="4. 不能解决的循环依赖"></a>4. 不能解决的循环依赖</h2><p>Spring 的三级缓存机制无法解决构造函数注入之间的循环依赖。因为在构造函数注入中，Bean 在创建期间无法暴露其早期引用，而构造器注入要求在创建对象时即完成所有依赖的注入。</p>
<p>下面这个链接讲的不错</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daimzh/p/13256413.html">面试必杀技，讲一讲Spring中的循环依赖 - 程序员DMZ - 博客园 (cnblogs.com)</a></p>
<h1 id="Spring注入方式"><a href="#Spring注入方式" class="headerlink" title="Spring注入方式"></a>Spring注入方式</h1><p>实例化方式有构造器实例化和工厂方式实例化</p>
<p>实例化后要注入属性，主要有</p>
<ul>
<li>构造器注入</li>
<li>setter方法注入</li>
<li>字段注入</li>
</ul>
<h2 id="1-构造器注入"><a href="#1-构造器注入" class="headerlink" title="1. 构造器注入"></a>1. 构造器注入</h2><h3 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h3><ol>
<li><strong>确保对象创建时依赖完整</strong>：<ul>
<li>通过构造器传递依赖，确保在对象被实例化时就具备所需的所有依赖。</li>
<li>如果缺少必要的依赖项，程序会在构造阶段立即发现问题，有助于编译时错误检测。</li>
</ul>
</li>
<li><strong>增强对象的不可变性</strong>：<ul>
<li>通过构造器注入，可以确保被注入的依赖在对象的生命周期内保持不变，设计上更符合不可变性的最佳实践。</li>
<li>提高了代码的稳定性和线程安全性，尤其在多线程环境中显得重要。</li>
</ul>
</li>
<li><strong>简化测试</strong>：<ul>
<li>构造器注入更便于编写单元测试，因为依赖项可以通过构造器直接传递，而无需借助依赖注入框架或容器。</li>
</ul>
</li>
<li><strong>强制依赖声明</strong>：<ul>
<li>构造器注入明确地表明了类的依赖关系，开发者无法忽略或遗漏必需的依赖项。</li>
<li>有助于理解类的依赖需求，提高代码的可读性。</li>
</ul>
</li>
<li><strong>易于调试和维护</strong>：<ul>
<li>因为构造器注入的依赖关系在实例化时就固定下来，所以调试和追踪依赖问题变得更加直接。</li>
</ul>
</li>
<li><strong>无需容器依赖</strong>：<ul>
<li>构造器注入避免了在某些情况下必须依赖于容器框架的局限性，允许更灵活地在非容器环境中使用。</li>
</ul>
</li>
</ol>
<h3 id="1-2-注意"><a href="#1-2-注意" class="headerlink" title="1.2 注意"></a>1.2 注意</h3><ol>
<li>如果用构造方法注入的时候，参数过多以至于代码过于臃肿，那么此时你需要考虑这个类的设计是否合理，这个类是否参杂了太多的其他无关功能，这个类是否做到了单一职责。</li>
<li>Spring 的三级缓存机制无法解决构造函数注入之间的循环依赖。因为在构造函数注入中，Bean 在创建期间无法暴露其早期引用，而构造器注入要求在创建对象时即完成所有依赖的注入。</li>
</ol>
<p>综合来看，构造器注入是一种非常稳健的依赖注入方式，适合在对象的依赖关系明确且稳定时使用。</p>
<h2 id="2-setter方法注入"><a href="#2-setter方法注入" class="headerlink" title="2. setter方法注入"></a>2. setter方法注入</h2><p>适用于当依赖是可选的，或者需要在初始化后动态改变时。</p>
<p>优点：提供更灵活的配置方式，允许对象在创建之后改变依赖关系。</p>
<p>缺点：可能导致对象在完全配置前处于不一致状态。不适用于需要不可变依赖的场景。</p>
<h2 id="3-字段注入"><a href="#3-字段注入" class="headerlink" title="3. 字段注入"></a>3. 字段注入</h2><h3 id="3-1-缺点"><a href="#3-1-缺点" class="headerlink" title="3.1 缺点"></a>3.1 缺点</h3><p>基于字段的依赖注入是一种常见的实现方法。然而，基于字段的依赖注入有几个明显的缺陷：</p>
<ol>
<li><p><strong>可测试性受限</strong>：<br>使用字段注入时，依赖通常是通过框架在运行时注入的，这意味着在不启动整个Spring容器的情况下，很难对这些组件进行单元测试。虽然可以使用反射来设置这些字段，但这种方法通常比较繁琐且容易出错。</p>
</li>
<li><p><strong>违反封装原则</strong>：<br>字段注入通常需要将字段设置为非私有（例如，包级私有或者受保护的），这违反了面向对象设计的封装原则。封装原则推荐通过构造函数或者方法来管理依赖，这样可以保证类的行为不会被外部错误地改变。</p>
</li>
<li><p><strong>隐式依赖关系</strong>：</p>
<ul>
<li><p><strong>难以理解</strong></p>
<p>新的开发人员或维护人员在阅读或审核代码时，可能不会立即意识到类依赖了哪些其他组件。他们需要深入检查每个字段的注解来确定依赖关系，这增加了理解和维护的难度。</p>
</li>
<li><p><strong>文档和工具支持不足</strong>：</p>
<p>构造器或方法注入相比，字段注入可能不会被一些自动化工具或文档生成工具如Javadoc等捕捉到，因为这些工具通常关注公共接口而非内部实现。</p>
</li>
</ul>
<p>相对地，构造器注入通过构造函数显式地声明依赖，使得依赖关系更加明显，便于理解和维护。</p>
</li>
<li><p><strong>框架耦合性增加</strong>：<br>字段注入使得代码与Spring框架更加紧密地耦合在一起。例如，通过使用 <code>@Autowired</code>注解实现的依赖注入使得组件难以脱离Spring环境被复用或迁移到其他框架中。</p>
</li>
<li><p><strong>运行时错误的可能性</strong>：<br>如果依赖没有被正确注入，基于字段的注入通常会在运行时才表现出问题，而构造器注入会在应用启动时立即抛出异常，因为依赖关系是通过构造器显式传递的。</p>
</li>
<li><p><strong>不支持不可变性</strong>：<br>使用字段注入很难实现不可变的依赖关系，因为字段通常需要在对象创建后设置。相比之下，构造器注入支持创建完全初始化且状态不变的对象，这有助于创建线程安全的应用。</p>
</li>
</ol>
<p>基于这些缺点，许多开发者和Spring的推荐实践趋向于使用构造器注入而不是字段注入，尽管在简单的场景下，字段注入依然是一个快速且方便的选项。</p>
<h2 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在实际开发中，选择使用哪种注入方式取决于具体的开发需求、代码风格和项目结构。</p>
<ul>
<li><strong>偏好构造器注入</strong>：因为它提供了明确的依赖关系，并鼓励不可变设计。</li>
<li><strong>适时使用 Setter 注入</strong>：在某些配置类或依赖项需要在运行时灵活切换的情况下。</li>
<li><strong>谨慎使用字段注入</strong>：通常在简单的服务类或工具类中使用，但要确保不会影响测试或代码可维护性。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7021780050618007582?searchId=20240505150948E0E95E3C7114D55E7CC0">扯一把 Spring 的三种注入方式，到底哪种注入方式最佳？ - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7275009721760432168?searchId=20240505145503A0E3E7905D2FD860600A">公司为什么禁止在SpringBoot项目中使用@Autowired注解 - 掘金 (juejin.cn)</a></p>
<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p><code>XmlBeanDefinitionReader</code>中添加对 <code>lazyInit</code>属性的解析</p>
<p><code>beanDefinition</code>中加入 <code>lazyInit</code>属性</p>
<p><code>DefaultListableBeanFactory</code>中添加对 <code>isLazyInit</code>的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    beanDefinitionMap.forEach((beanName, beanDefinition) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton() &amp;&amp; !beanDefinition.isLazyInit())&#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h1><h2 id="1-ProxyFactory"><a href="#1-ProxyFactory" class="headerlink" title="1. ProxyFactory"></a>1. ProxyFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">extends</span> <span class="title class_">AdvisedSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动判断使用JDK还是CGLIB动态代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isProxyTargetClass() || <span class="built_in">this</span>.getTargetSource().getTargetClass().length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CglibAopProxy</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-AdvisedSupport-1"><a href="#2-AdvisedSupport-1" class="headerlink" title="2. AdvisedSupport"></a>2. AdvisedSupport</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理方式（默认JDK动态代理）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">proxyTargetClass</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法匹配器</span></span><br><span class="line"><span class="keyword">private</span> MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存拦截器链</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;Integer, List&lt;Object&gt;&gt; methodCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截器链工厂</span></span><br><span class="line"><span class="type">AdvisorChainFactory</span> <span class="variable">advisorChainFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorChainFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的Advisor实例（每一个Advisor包含一个切面Advice和一个切点Pointcut）</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回拦截器链</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法的哈希码作为键</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">cacheKey</span> <span class="operator">=</span> method.hashCode();</span><br><span class="line">    <span class="comment">// 根据缓存键获取已缓存的拦截器列表</span></span><br><span class="line">    List&lt;Object&gt; cached = <span class="built_in">this</span>.methodCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取拦截器和动态拦截器通知</span></span><br><span class="line">        cached = <span class="built_in">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<span class="built_in">this</span>, method, targetClass);</span><br><span class="line">        <span class="comment">// 将获取到的拦截器列表放入方法缓存中</span></span><br><span class="line">        <span class="built_in">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-基于JDK动态代理"><a href="#3-基于JDK动态代理" class="headerlink" title="3. 基于JDK动态代理"></a>3. 基于JDK动态代理</h2><ol>
<li>获取拦截器链</li>
<li>将拦截器统一封装成ReflectiveMethodInvocation</li>
<li>执行拦截器链</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 获取目标对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> advised.getTargetSource().getTarget();</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 获取拦截器链</span></span><br><span class="line">    List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="literal">null</span> || chain.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 如果拦截器链为空，那就执行原有方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 如果拦截器链不为空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 将拦截器统一封装成ReflectiveMethodInvocation</span></span><br><span class="line">        <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">        <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">        <span class="comment">// 3. 执行拦截器链</span></span><br><span class="line">        retVal = invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-获取拦截器链"><a href="#4-获取拦截器链" class="headerlink" title="4. 获取拦截器链"></a>4. 获取拦截器链</h2><p>拦截器链工厂，就是将 <code>AdvisedSupport</code>中所有满足条件的 <code>advisor</code>都放进一个集合当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title class_">AdvisorChainFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(AdvisedSupport config, Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 AdvisedSupport 对象中获取所有的 Advisor 实例，将它们转化为 Advisor 数组。</span></span><br><span class="line">        Advisor[] advisors = config.getAdvisors().toArray(<span class="keyword">new</span> <span class="title class_">Advisor</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截器链容器</span></span><br><span class="line">        List&lt;Object&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(advisors.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定实际的类：如果传入的 targetClass 不为空，则使用 targetClass；如果为空，则使用方法所属的类。</span></span><br><span class="line">        Class&lt;?&gt; actualClass = (targetClass != <span class="literal">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的 Advisor，将满足条件的 Advisor 处理为 MethodInterceptor 加入到 interceptorList。</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// 检查 Advisor 是否为 PointcutAdvisor 类型。只有 PointcutAdvisor 才有 Pointcut 和 MethodMatcher 的概念</span></span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">                <span class="comment">// Add it conditionally.</span></span><br><span class="line">                <span class="type">PointcutAdvisor</span> <span class="variable">pointcutAdvisor</span> <span class="operator">=</span> (PointcutAdvisor) advisor;</span><br><span class="line">                <span class="comment">// 通过 Pointcut 中的 ClassFilter 来检查该 Advisor 是否适用于当前类。如果适用，则继续检查方法。</span></span><br><span class="line">                <span class="keyword">if</span> (pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    <span class="type">MethodMatcher</span> <span class="variable">mm</span> <span class="operator">=</span> pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                    <span class="type">boolean</span> match;</span><br><span class="line">                    <span class="comment">// 使用 matches 方法检查 Advisor 是否适用于当前的方法。（底层用到了aspectj框架，原理暂时不会）</span></span><br><span class="line">                    match = mm.matches(method,actualClass);</span><br><span class="line">                    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                        <span class="comment">// 如果匹配成功，将 Advisor 中的 Advice 转换为 MethodInterceptor 并加入到 interceptorList 中。</span></span><br><span class="line">                        <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (MethodInterceptor) advisor.getAdvice();</span><br><span class="line">                        interceptorList.add(interceptor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-将拦截器统一封装成ReflectiveMethodInvocation"><a href="#5-将拦截器统一封装成ReflectiveMethodInvocation" class="headerlink" title="5. 将拦截器统一封装成ReflectiveMethodInvocation"></a>5. 将拦截器统一封装成ReflectiveMethodInvocation</h2><p>完善 <code>ReflectiveMethodInvocation</code>成员变量，重写 <code>proceed()</code>方法，使之支持多切面</p>
<h2 id="6-执行拦截器链"><a href="#6-执行拦截器链" class="headerlink" title="6. 执行拦截器链"></a>6. 执行拦截器链</h2><p>使用递归的方式来使之顺序执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 初始currentInterceptorIndex为-1，每调用一次proceed就把currentInterceptorIndex+1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当调用次数 = 拦截器个数时</span></span><br><span class="line">        <span class="comment">// 触发当前method方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.target, <span class="built_in">this</span>.arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="comment">// 普通拦截器，内部还会继续调用proceed()方法，直接触发拦截器invoke方法</span></span><br><span class="line">    <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以两个 <code>After</code>和两个 <code>before</code>为例</p>
<p><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/image-20240505211810554.png" alt="image-20240505211810554"></p>
<h2 id="7-责任链模式"><a href="#7-责任链模式" class="headerlink" title="7. 责任链模式"></a>7. 责任链模式</h2><p>责任链模式是一种行为设计模式，它允许多个对象都有机会处理请求，将这些对象连成一条链。责任链中的每个对象都包含对下一个对象的引用，并在处理请求时要么自行处理，要么将请求传递给链中的下一个对象。</p>
<p>Spring AOP中，递归调用拦截器链中的每一个节点，根据拦截器的实现来决定插入逻辑的顺序。</p>
<hr>
<blockquote>
<p>一是深度，二是广度，知识一定要有体系。</p>
</blockquote>
<blockquote>
<p>解析xml文件的好几种方式</p>
<p>解析properties文件的方式</p>
<p>解析注解的方式</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Easton Voyager</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/06/Spring/my-mini-spring/">http://example.com/2024/05/06/Spring/my-mini-spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Easton Voyager</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/04/15/Spring/SpringMVC/" title="SpringMVC"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringMVC</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Easton Voyager</div><div class="author-info__description">描述描述描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">导言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">1.2.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">1.3.</span> <span class="toc-text">ApplicationContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">1.4.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">1.5.</span> <span class="toc-text">BeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">1. 接口的多态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E5%81%9A%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">2. 接口做识别功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">Spring-软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">1. 接口隔离原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">3.2.</span> <span class="toc-text">2. 合成复用原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">Spring-设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1. 工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2. 单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3. 模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4. 建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5. 外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">6. 策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">7. 适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">8. 观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">9. 代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.</span> <span class="toc-text">10. 责任链模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84bean%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">最简单的bean容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">6.</span> <span class="toc-text">Bean实例化策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">注入属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">资源和资源加载器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XML%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">XML解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BeanFactoryPostProcessor"><span class="toc-number">10.1.</span> <span class="toc-text">1. BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BeanPostProcessor"><span class="toc-number">10.2.</span> <span class="toc-text">2. BeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">11.</span> <span class="toc-text">应用上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">11.1.</span> <span class="toc-text">1. 继承体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-refresh%E5%92%8CgetBean"><span class="toc-number">11.2.</span> <span class="toc-text">2. refresh和getBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-getBean-%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%8F%96Bean%E5%AE%9E%E4%BE%8B"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1 getBean 从容器中获取Bean实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%9B%AE%E5%89%8D%E8%AE%A4%E4%B8%BA%E7%9A%84%E9%87%8D%E7%82%B9"><span class="toc-number">11.3.</span> <span class="toc-text">3. 目前认为的重点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">初始化和销毁方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%A8%E5%88%B0%E7%9A%84%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">1. 用到的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E7%82%B9"><span class="toc-number">12.2.</span> <span class="toc-text">2. 重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">3. 适配器模式的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aware%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.</span> <span class="toc-text">Aware接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BeanFactoryAware"><span class="toc-number">13.1.</span> <span class="toc-text">1. BeanFactoryAware</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ApplicationContextAware"><span class="toc-number">13.2.</span> <span class="toc-text">2. ApplicationContextAware</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FactoryBean"><span class="toc-number">15.</span> <span class="toc-text">FactoryBean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">容器事件和事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.1.</span> <span class="toc-text">1. 观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BB%93%E6%9E%84"><span class="toc-number">16.1.1.</span> <span class="toc-text">1.1 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.1.2.</span> <span class="toc-text">1.2 实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring%E5%AF%B9%E8%AF%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.1.3.</span> <span class="toc-text">1.3 Spring对该模式的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%BF%E6%92%AD%E5%99%A8"><span class="toc-number">16.2.</span> <span class="toc-text">2. 广播器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%91%E5%B8%83"><span class="toc-number">16.3.</span> <span class="toc-text">3. 发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%86%85%E5%B5%8C%E5%8F%91%E5%B8%83"><span class="toc-number">16.3.1.</span> <span class="toc-text">3.1 内嵌发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%89%8B%E5%8A%A8%E5%8F%91%E5%B8%83"><span class="toc-number">16.3.2.</span> <span class="toc-text">3.2 手动发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8F%91%E5%B8%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">16.3.3.</span> <span class="toc-text">3.3 发布的实现过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">16.4.</span> <span class="toc-text">4. 事件+监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0BeanFactoryAware%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.5.</span> <span class="toc-text">5. 实现BeanFactoryAware接口的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">16.5.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.5.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.5.3.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryAware-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.5.4.</span> <span class="toc-text">BeanFactoryAware 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">16.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="toc-number">17.</span> <span class="toc-text">优化性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.1.</span> <span class="toc-text">1. 对象池模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">17.2.</span> <span class="toc-text">2. 懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A2%84%E5%85%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-number">17.3.</span> <span class="toc-text">3. 预先初始化（预加载）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">17.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP"><span class="toc-number">18.</span> <span class="toc-text">Spring-AOP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">切点表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E8%AF%AD"><span class="toc-number">19.1.</span> <span class="toc-text">1. 原语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.2.</span> <span class="toc-text">2. 常用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-PointcutPrimitive"><span class="toc-number">19.2.1.</span> <span class="toc-text">2.1 PointcutPrimitive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-PointcutParser"><span class="toc-number">19.2.2.</span> <span class="toc-text">2.2 PointcutParser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-PointcutExpression"><span class="toc-number">19.2.3.</span> <span class="toc-text">2.3 PointcutExpression</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">19.3.</span> <span class="toc-text">3. 代码：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-JDK"><span class="toc-number">20.</span> <span class="toc-text">动态代理-JDK</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">20.1.</span> <span class="toc-text">1. 简单示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BC%BA%E7%82%B9"><span class="toc-number">20.1.1.</span> <span class="toc-text">1.1 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AdvisedSupport"><span class="toc-number">20.2.</span> <span class="toc-text">2. AdvisedSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ReflectiveMethodInvocation"><span class="toc-number">20.3.</span> <span class="toc-text">3. ReflectiveMethodInvocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JdkDynamicAopProxy"><span class="toc-number">20.4.</span> <span class="toc-text">4. JdkDynamicAopProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-InvocationHandler"><span class="toc-number">20.5.</span> <span class="toc-text">5. InvocationHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">20.6.</span> <span class="toc-text">6. 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%83%A8%E5%88%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">20.7.</span> <span class="toc-text">7. 部分原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%B8%AD%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.7.1.</span> <span class="toc-text">7.1 查看内存中动态代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%86%E6%9E%90"><span class="toc-number">20.7.2.</span> <span class="toc-text">7.2 动态代理类分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%98%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">20.8.</span> <span class="toc-text">8. 还不会的地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.9.</span> <span class="toc-text">9. 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.9.1.</span> <span class="toc-text">9.1 代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%84%9F%E7%9F%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.9.2.</span> <span class="toc-text">9.2 感知设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-CGLIB"><span class="toc-number">21.</span> <span class="toc-text">动态代理-CGLIB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82"><span class="toc-number">22.</span> <span class="toc-text">AOP代理工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JDK-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AF%94%E8%BE%83"><span class="toc-number">22.1.</span> <span class="toc-text">1. JDK CGLIB 动态代理比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8Advice"><span class="toc-number">23.</span> <span class="toc-text">常用Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">23.1.</span> <span class="toc-text">1. 执行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PointcutAdvisor-Pointcut%E5%92%8CAdvice%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">24.</span> <span class="toc-text">PointcutAdvisor: Pointcut和Advice的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">24.1.</span> <span class="toc-text">1. &lt;aspect&gt;和 &lt;advisor&gt;的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%8A-%E4%BD%BF%E7%94%A8%E4%B8%8A"><span class="toc-number">24.1.1.</span> <span class="toc-text">代码上 使用上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%9E%8D%E5%85%A5bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">25.</span> <span class="toc-text">动态代理融入bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">25.1.</span> <span class="toc-text">1. 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%BA%E9%99%B7"><span class="toc-number">25.2.</span> <span class="toc-text">2. 缺陷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">26.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8C%85%E6%89%AB%E6%8F%8F%E3%80%81-Component%E6%B3%A8%E8%A7%A3%E8%AF%86%E5%88%AB%EF%BC%8C%E6%B3%A8%E5%85%A5beanDefinition%EF%BC%8C%E6%B3%A8%E5%86%8CAutowiredAnnotationBeanPostProcessor"><span class="toc-number">26.1.</span> <span class="toc-text">1. 包扫描、@Component注解识别，注入beanDefinition，注册AutowiredAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%8C%96bean%EF%BC%8C-Value%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%EF%BC%8C%E4%B8%BAbean%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">26.2.</span> <span class="toc-text">2. 实例化bean，@Value注解扫描，为bean注入属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-Autowired%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91"><span class="toc-number">26.2.1.</span> <span class="toc-text">添加@Autowired操作逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">26.3.</span> <span class="toc-text">3. 占位符解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">26.3.1.</span> <span class="toc-text">3.1 解析xml文件中的占位符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A7%A3%E6%9E%90-Value%E6%B3%A8%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">26.3.2.</span> <span class="toc-text">3.2 解析@Value注解中的占位符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">26.3.3.</span> <span class="toc-text">3.3 适配器模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fix"><span class="toc-number">27.</span> <span class="toc-text">fix</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">27.1.</span> <span class="toc-text">1. 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-number">27.2.</span> <span class="toc-text">2. 前置处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-number">27.3.</span> <span class="toc-text">3. 后置处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">28.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">28.1.</span> <span class="toc-text">1. 基础类关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">28.2.</span> <span class="toc-text">2. 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">28.2.1.</span> <span class="toc-text">2.1 适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">28.2.2.</span> <span class="toc-text">2.2 策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%B6%E4%BB%96"><span class="toc-number">28.2.3.</span> <span class="toc-text">2.3 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">28.3.</span> <span class="toc-text">3. 执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%AD%E5%BF%83%E6%9C%AC%E8%BA%AB"><span class="toc-number">28.3.1.</span> <span class="toc-text">3.1 转换器和类型转换中心本身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%AD%E5%BF%83"><span class="toc-number">28.3.2.</span> <span class="toc-text">3.2 注入类型转换中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%AE%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%AD%E5%BF%83"><span class="toc-number">28.3.3.</span> <span class="toc-text">3.3 设置类型转换中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%AD%E5%BF%83%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">28.3.4.</span> <span class="toc-text">3.4 使用类型转换中心中的转换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%BC%80%E5%8F%91%E8%80%85%E4%BD%BF%E7%94%A8"><span class="toc-number">28.3.5.</span> <span class="toc-text">3.5 开发者使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">28.4.</span> <span class="toc-text">4. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%94%B6%E8%8E%B7"><span class="toc-number">28.4.1.</span> <span class="toc-text">4.1 收获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">28.4.2.</span> <span class="toc-text">4.2 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%B3%A8%E6%84%8F"><span class="toc-number">28.4.3.</span> <span class="toc-text">4.3 注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">29.</span> <span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-number">29.1.</span> <span class="toc-text">1. 解决循环依赖的前置条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8%E5%88%B0%E7%9A%84%E7%B1%BB"><span class="toc-number">29.2.</span> <span class="toc-text">2. 用到的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">29.3.</span> <span class="toc-text">3. 简单示例&amp;执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">29.4.</span> <span class="toc-text">4. 不能解决的循环依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">30.</span> <span class="toc-text">Spring注入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">30.1.</span> <span class="toc-text">1. 构造器注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%98%E7%82%B9"><span class="toc-number">30.1.1.</span> <span class="toc-text">1.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E6%84%8F"><span class="toc-number">30.1.2.</span> <span class="toc-text">1.2 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-number">30.2.</span> <span class="toc-text">2. setter方法注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="toc-number">30.3.</span> <span class="toc-text">3. 字段注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BC%BA%E7%82%B9"><span class="toc-number">30.3.1.</span> <span class="toc-text">3.1 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93-1"><span class="toc-number">30.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">31.</span> <span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">32.</span> <span class="toc-text">拦截器链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ProxyFactory"><span class="toc-number">32.1.</span> <span class="toc-text">1. ProxyFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AdvisedSupport-1"><span class="toc-number">32.2.</span> <span class="toc-text">2. AdvisedSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">32.3.</span> <span class="toc-text">3. 基于JDK动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">32.4.</span> <span class="toc-text">4. 获取拦截器链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B0%86%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85%E6%88%90ReflectiveMethodInvocation"><span class="toc-number">32.5.</span> <span class="toc-text">5. 将拦截器统一封装成ReflectiveMethodInvocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">32.6.</span> <span class="toc-text">6. 执行拦截器链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">32.7.</span> <span class="toc-text">7. 责任链模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mini-spring原理解析"/></a><div class="content"><a class="title" href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析">mini-spring原理解析</a><time datetime="2024-05-06T14:52:00.000Z" title="发表于 2024-05-06 22:52:00">2024-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Spring/SpringMVC/" title="SpringMVC"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"/></a><div class="content"><a class="title" href="/2024/04/15/Spring/SpringMVC/" title="SpringMVC">SpringMVC</a><time datetime="2024-04-15T13:46:00.000Z" title="发表于 2024-04-15 21:46:00">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Spring/Spring/" title="Spring"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2024/04/15/Spring/Spring/" title="Spring">Spring</a><time datetime="2024-04-15T13:46:00.000Z" title="发表于 2024-04-15 21:46:00">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="动态代理"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态代理"/></a><div class="content"><a class="title" href="/2024/04/15/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="动态代理">动态代理</a><time datetime="2024-04-15T13:38:00.000Z" title="发表于 2024-04-15 21:38:00">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%B3%A8%E8%A7%A3/" title="注解"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="注解"/></a><div class="content"><a class="title" href="/2024/04/15/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%B3%A8%E8%A7%A3/" title="注解">注解</a><time datetime="2024-04-15T13:38:00.000Z" title="发表于 2024-04-15 21:38:00">2024-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Easton Voyager</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>