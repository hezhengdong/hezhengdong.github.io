<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mini-springmvc原理解析 | Voyager001</title><meta name="author" content="Voyager001"><meta name="copyright" content="Voyager001"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="导言Spring MVC是基于MVC架构（模型-视图-控制器）的高级Web框架，建立在Spring IOC容器之上，底层通过高度整合的组件实现了对Web应用中控制层的完整管理。基于Spring框架的强大基础，致力于提供一个高效、灵活的Web应用开发环境。 Spring MVC的核心组件包括处理器映射器、处理器适配器、拦截器等，核心组件的设计允许高度的模块化和可拓展性，通过共同协作，扩展并优化了请求">
<meta property="og:type" content="article">
<meta property="og:title" content="mini-springmvc原理解析">
<meta property="og:url" content="http://hezhengdong.github.io/2024/05/21/Spring/my-mini-springmvc/index.html">
<meta property="og:site_name" content="Voyager001">
<meta property="og:description" content="导言Spring MVC是基于MVC架构（模型-视图-控制器）的高级Web框架，建立在Spring IOC容器之上，底层通过高度整合的组件实现了对Web应用中控制层的完整管理。基于Spring框架的强大基础，致力于提供一个高效、灵活的Web应用开发环境。 Spring MVC的核心组件包括处理器映射器、处理器适配器、拦截器等，核心组件的设计允许高度的模块化和可拓展性，通过共同协作，扩展并优化了请求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hezhengdong.github.io/img/spring-logo.png">
<meta property="article:published_time" content="2024-05-21T11:14:21.000Z">
<meta property="article:modified_time" content="2024-05-25T06:51:07.375Z">
<meta property="article:author" content="Voyager001">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hezhengdong.github.io/img/spring-logo.png"><link rel="shortcut icon" href="https://lovely-picture.oss-cn-beijing.aliyuncs.com/genshin/nahida-lovaly-001.jpg"><link rel="canonical" href="http://hezhengdong.github.io/2024/05/21/Spring/my-mini-springmvc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mini-springmvc原理解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-25 14:51:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://lovely-picture.oss-cn-beijing.aliyuncs.com/star_rail/match7th001.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> others</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/message/"><i class="fa-fw fas fa-comments"></i><span> message</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/spring-logo.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Voyager001"><span class="site-name">Voyager001</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> others</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/message/"><i class="fa-fw fas fa-comments"></i><span> message</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mini-springmvc原理解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-21T11:14:21.000Z" title="发表于 2024-05-21 19:14:21">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-25T06:51:07.375Z" title="更新于 2024-05-25 14:51:07">2024-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mini-springmvc原理解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/05/21/Spring/my-mini-springmvc/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>Spring MVC是基于MVC架构（模型-视图-控制器）的高级Web框架，建立在Spring IOC容器之上，底层通过高度整合的组件实现了对Web应用中控制层的完整管理。基于Spring框架的强大基础，致力于提供一个高效、灵活的Web应用开发环境。</p>
<p>Spring MVC的<strong>核心组件</strong>包括<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>拦截器</strong>等，核心组件的设计允许高度的模块化和可拓展性，通过共同协作，扩展并优化了请求的处理流程。</p>
<p><strong>处理器映射器</strong>建立请求路径与处理器间的映射关系，返回处理器链对象，保证了请求能被正确分发至相应的处理器；</p>
<p><strong>处理器适配器</strong>提供了强大的数据绑定机制，通过参数解析器与返回值处理器，自动将输入输出数据与Java应用的数据模型相连接，极大简化了前后端间流转数据的处理；</p>
<p><strong>拦截器</strong>则在此基础上提供了请求处理前后的拦截功能，增加了处理流程的灵活性和安全性。</p>
<p><strong>DispatcherServlet</strong>是整个MVC流程的中枢，负责协调各组件的执行，完成对HTTP请求的调度分发。</p>
<p><strong>全局异常处理器</strong>处理整个应用中抛出的异常，通过集中处理所有控制器层面的异常，统一管理错误处理逻辑，返回结构化的错误响应，显著提升了程序的健壮性。</p>
<p><strong>核心配置类</strong>利用Spring框架的控制反转和依赖注入，整合各个组件，管理和配置框架所需的各种资源和服务；将业务逻辑与配置逻辑分离，为应用的启动和运行提供了统一的配置入口，使得整个系统更加简洁和模块化。</p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>（蓝色为已经淘汰的JSP技术，前后端分离开发模式下并不用考虑）</p>
<p><img src="https://typora-hezhengdong-image.oss-cn-beijing.aliyuncs.com/PicGo/Spring%20MVC.jpg" alt="spring_mvc"></p>
<h3 id="1-处理器映射器"><a href="#1-处理器映射器" class="headerlink" title="1. 处理器映射器"></a>1. 处理器映射器</h3><ol>
<li><a href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">处理器映射器-建立映射关系</a></li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-%E8%BF%94%E5%9B%9E%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE%E5%AF%B9%E8%B1%A1">处理器映射器-返回处理器链对象</a></li>
</ol>
<h3 id="2-处理器适配器"><a href="#2-处理器适配器" class="headerlink" title="2. 处理器适配器"></a>2. 处理器适配器</h3><ol>
<li><a href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8">参数解析器</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8">返回值处理器</a></li>
<li><a href="#Handler%E6%89%A7%E8%A1%8C%E5%99%A8">Handler执行器</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8">处理器适配器</a></li>
</ol>
<h3 id="3-视图解析器"><a href="#3-视图解析器" class="headerlink" title="3. 视图解析器"></a>3. 视图解析器</h3><ol>
<li><a href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E6%B8%B2%E6%9F%93">视图的渲染</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">视图解析器</a></li>
</ol>
<h3 id="4-DispatcherServlet"><a href="#4-DispatcherServlet" class="headerlink" title="4. DispatcherServlet"></a><a href="#DispatcherServlet">4. DispatcherServlet</a></h3><h3 id="5-全局异常处理器"><a href="#5-全局异常处理器" class="headerlink" title="5. 全局异常处理器"></a><a href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8">5. 全局异常处理器</a></h3><h3 id="6-核心配置类"><a href="#6-核心配置类" class="headerlink" title="6. 核心配置类"></a><a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%B1%BB">6. 核心配置类</a></h3><p><code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>当核心类看不懂的时候看看接口，接口定义了最核心的功能要求，能够从更高的视角观察代码底层的主要逻辑</strong></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a>：控制对另一个拦截器的访问，基于URL模式的匹配结果来决定是否调用实际拦截器的方法</p>
<h2 id="2-责任链模式"><a href="#2-责任链模式" class="headerlink" title="2. 责任链模式"></a>2. 责任链模式</h2><p>拦截器链的设计用到了责任链模式。</p>
<p>责任链模式：允许多个对象处理一个请求，而发送请求的客户端并不需要知道请求的具体处理者是谁。每个处理器都有机会处理请求，并且有责任决定自己是否能处理该请求。请求沿着一条链传递，从一个对象传递到下一个对象，直到有对象处理该请求为止。</p>
<p>在请求传递时，每个拦截器都扮演责任链中的一个节点，拦截器链按照顺序调用多个拦截器，每个拦截器会检查或处理进来的请求，并决定是否将请求传递给链中的下一个拦截器。</p>
<h2 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h2><p><a href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8">参数解析器</a>、<a href="%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8">返回值处理器</a></p>
<p>都是通过复合类，底层自动根据参数匹配合适的解析器方法</p>
<h1 id="处理器映射器-建立映射关系"><a href="#处理器映射器-建立映射关系" class="headerlink" title="处理器映射器-建立映射关系"></a>处理器映射器-建立映射关系</h1><p><code>RequestMappingHandlerMapping</code>初始化过程</p>
<p>实现了 <code>HandlerMapping</code>的初始化, 了解到了 <code>Controller</code>中的方法是如何转换成 <code>HandlerMethod</code></p>
<p>在应用上下文配置环境执行 <code>refresh()</code>方法时，建立起映射关系</p>
<h2 id="1-组成组件"><a href="#1-组成组件" class="headerlink" title="1. 组成组件"></a>1. 组成组件</h2><p><code>RequestMapping</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="comment">// 类&amp;方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 用于指示其他注解是否应该包含在 Java 文档中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示url中的路径</span></span><br><span class="line">    String <span class="title function_">path</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示http请求的方式</span></span><br><span class="line">    RequestMethod <span class="title function_">method</span><span class="params">()</span> <span class="keyword">default</span> RequestMethod.GET;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RequestMethod</code>枚举类，定义了请求方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">    GET, POST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RequestMappingInfo</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示请求映射信息的类，包含了一个关于请求映射的所有信息</span></span><br><span class="line"><span class="comment"> * 如url路径、http请求方法、请求参数、请求头等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http请求方法</span></span><br><span class="line">    <span class="keyword">private</span> RequestMethod httpMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RequestMappingInfo</span><span class="params">(String prefix, RequestMapping requestMapping)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = prefix + requestMapping.path();</span><br><span class="line">        <span class="built_in">this</span>.httpMethod = requestMapping.method();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//getter setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HandlerMethod</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理程序方法的类</span></span><br><span class="line"><span class="comment"> * 用于根据信息执行对应方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示处理程序方法的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法所属的类</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法对象</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法参数对象列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodParameter&gt; parameters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerMethod</span><span class="params">(Object bean, Method method)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">        <span class="built_in">this</span>.beanType = bean.getClass();</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.parameters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> method.getParameterCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; parameterCount; index++) &#123;</span><br><span class="line">            parameters.add(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(method, index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MappingRegistry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有映射(RequestMappingInfo,HandlerMethod)的注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储url与RequestMappingInfo之间的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, RequestMappingInfo&gt; pathMappingInfo = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储url与HandlerMethod对象之间的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, HandlerMethod&gt; pathHandlerMethod = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册url和Mapping/HandlerMethod的对应关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapping 表示请求映射信息，如url路径、http请求方法、请求参数、请求头等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 表示处理程序方法的对象，即要执行方法的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 要执行类的方法对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(RequestMappingInfo mapping, Object handler, Method method)</span> &#123;</span><br><span class="line">        pathMappingInfo.put(mapping.getPath(), mapping);</span><br><span class="line"></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(handler, method);</span><br><span class="line">        pathHandlerMethod.put(mapping.getPath(), handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//getter setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-核心类-执行流程"><a href="#2-核心类-执行流程" class="headerlink" title="2. 核心类&amp;执行流程"></a>2. 核心类&amp;执行流程</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><code>RequestMappingHandlerMapping</code>处理Http请求映射的核心组件</p>
<p>负责管理请求映射信息，以实现客户端请求到处理程序方法的路由和分发</p>
<h3 id="2-2-具体步骤-类详解"><a href="#2-2-具体步骤-类详解" class="headerlink" title="2.2 具体步骤&amp;类详解"></a>2.2 具体步骤&amp;类详解</h3><ol>
<li>解析 <code>@RequestMapping</code>注解，获取请求信息</li>
<li>管理请求映射信息：将请求路径与处理程序方法 <code>HandlerMethod</code>建立映射管理</li>
<li>在收到 HTTP 请求时，根据请求路径和请求方法找到相应的处理程序方法，以便执行具体的请求处理逻辑</li>
</ol>
<p><strong>类关系（继承与实现）</strong></p>
<p>extends <code>ApplicationObjectSupport</code></p>
<p>该抽象类里面实现了 <code>ApplicationAware</code>接口，在这里的主要是使 <code>RequestMappingHandlerMapping</code>感知 <code>ApplicationContext</code>应用上下文，获取容器中所有bean</p>
<p>implements <code>HandlerMapping</code>, <code>InitializingBean</code></p>
<p>别把 <code>InitializingBean</code>接口忘了，跟 <code>init_method</code>一个效果，<strong>重写接口中的方法用于插入初始化方法！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取Spring容器中所有的bean及其beanName</span></span><br><span class="line">    Map&lt;String, Object&gt; beansOfMap = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), Object.class);</span><br><span class="line">    beansOfMap.entrySet().stream()</span><br><span class="line">            <span class="comment">// 2. 过滤出所有带@Controller注解的类</span></span><br><span class="line">            .filter(entry -&gt; <span class="built_in">this</span>.isHandler(entry.getValue()))</span><br><span class="line">            <span class="comment">// 3. 查找@RequestMapping注解，自动发现并注册http请求处理方法</span></span><br><span class="line">            .forEach(entry -&gt; <span class="built_in">this</span>.detectHandlerMethods(entry.getKey(), entry.getValue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isHandler()</code>方法内部使用了 <code>AnnotatedElementUtils.hasAnnotation</code></p>
<p><code>detectHandlerMethods()</code>方法内部遍历所有bean，处理 <code>@RequestMapping</code>注解，封装为 <code>RequestMappingInfo</code>对象，然后将其注册进 <code>mappingRegistry</code>中，<strong>从而将请求路径与处理程序方法 <code>HandlerMethod</code>建立映射关系</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(String beanName, Object handler)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; beanType = handler.getClass();</span><br><span class="line">    Map&lt;Method, RequestMappingInfo&gt; methodsOfMap = MethodIntrospector.selectMethods(beanType,</span><br><span class="line">            <span class="comment">// 函数式接口，检查每一个方法，如果方法上有@RequestMapping注解，返回RequestMappingInfo实例</span></span><br><span class="line">            (MethodIntrospector.MetadataLookup&lt;RequestMappingInfo&gt;) method -&gt; getMappingForMethod(method, beanType));</span><br><span class="line">    <span class="comment">// 注册映射，将方法、处理器和请求映射信息注册到MappingRegistry</span></span><br><span class="line">    methodsOfMap.forEach((method, requestMappingInfo) -&gt; <span class="built_in">this</span>.mappingRegistry.register(requestMappingInfo, handler, method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找method上面是否有RequestMapping，有 =&gt; 构建RequestMappingInfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RequestMappingInfo <span class="title function_">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; beanType)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用AnnotatedElementUtils.findMergedAnnotation来查找方法上的@RequestMapping注解，返回值为具体@RequestMapping注解</span></span><br><span class="line">    <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(requestMapping)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> getPathPrefix(beanType);</span><br><span class="line">    <span class="comment">// 返回RequestMappingInfo实现类，RequestMappingInfo构造方法中会自动拼接路径: 类path+(方法path+方法对象)==(类path+方法path)+方法对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(prefix, requestMapping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getPathPrefix</span><span class="params">(Class&lt;?&gt; beanType)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用AnnotatedElementUtils.findMergedAnnotation查找类上是否有@RequestMapping注解</span></span><br><span class="line">    <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(beanType, RequestMapping.class);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(requestMapping)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有的话，取出path属性作为请求映射的路径前缀</span></span><br><span class="line">    <span class="keyword">return</span> requestMapping.path();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-如何集成进上下文环境"><a href="#2-3-如何集成进上下文环境" class="headerlink" title="2.3 如何集成进上下文环境"></a>2.3 如何集成进上下文环境</h3><p>上面所有的逻辑都被放入到 <code>InitializingBean</code>的 <code>afterPropertiesSet()</code>中，交由 <code>ApplicationContext#refresh()</code>统一管理，从而实现集成！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements InitializingBean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    initialHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-两个工具类"><a href="#3-两个工具类" class="headerlink" title="3. 两个工具类"></a>3. 两个工具类</h2><p>使用了两个工具类的三个方法</p>
<p><code>BeanFactoryUtils</code></p>
<ul>
<li><code>beansOfTypeIncludingAncestors()</code>获取Spring容器中所有的bean及其beanName</li>
</ul>
<p><code>AnnotatedElementUtils</code></p>
<ul>
<li><p><code>hasAnnotation()</code>过滤出所有带 <code>@Controller</code>注解的类</p>
<ul>
<li>原理还是回到了 <code>findAnnotations()</code>上</li>
</ul>
</li>
<li><p><code>findMergedAnnotation()</code></p>
<ul>
<li><p>两个参数：</p>
<ul>
<li><code>element</code>-带注解的元素</li>
<li><code>annotationType</code>-要查找的注解类型</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>合并的、合成的<strong>注解实例</strong>，或者null</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li>内部先通过 <code>AnnotationFilter</code>匹配注解，然后调用 <code>getDeclaredAnnotation()</code>获取注解实例，再底层就涉及到了反射获取注解。</li>
<li>返回合并的注解（继承和覆盖），原理太复杂，没看</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-合并注解的原理及意义"><a href="#4-合并注解的原理及意义" class="headerlink" title="4. 合并注解的原理及意义"></a>4. 合并注解的原理及意义</h2><p>by ChatGPT4</p>
<p>合并注解的原理是 Spring Framework 中用于处理注解继承、重写和组合的一种高级技术。它主要涉及到注解的合并策略，以及如何处理由多个注解或其属性构成的复杂关系。在 Spring 中，这个机制主要通过几个核心组件来实现：</p>
<h3 id="核心组件和类"><a href="#核心组件和类" class="headerlink" title="核心组件和类"></a>核心组件和类</h3><ol>
<li>**<code>AnnotatedElementUtils</code>**：这个类提供了静态方法来搜索带注解的元素（如类、方法或字段），并考虑了注解的继承关系和元注解。</li>
<li><strong><code>MergedAnnotations</code> API</strong>：从 Spring 5.2 开始，Spring 引入了 <code>MergedAnnotations</code> API，这是一个用于从类或方法等元素中获取注解信息的高性能、低内存占用的API。这个 API 能够处理注解的合并，并解析注解的层次结构。</li>
<li>**<code>MergedAnnotation</code>**：表示一个可能来自多个源的合并后的注解。它不仅包含注解本身的信息，还包括合并过程中的元数据，如注解是否是显式声明的、继承的或通过元注解合成的。</li>
</ol>
<h3 id="合并原理的步骤"><a href="#合并原理的步骤" class="headerlink" title="合并原理的步骤"></a>合并原理的步骤</h3><p>合并注解的过程可以分为以下几个步骤：</p>
<ol>
<li><strong>收集注解</strong>：从给定的 <code>AnnotatedElement</code>（可以是类、方法、字段等）收集所有相关的注解，包括直接声明的注解和通过继承获得的注解。</li>
<li><strong>处理元注解</strong>：元注解是应用于其他注解的注解。例如，<code>@Transactional</code> 可以用 <code>@MetaAnnotation</code> 标记。在处理一个注解时，Spring 也会查找其元注解，并将这些注解的属性合并到主注解中。</li>
<li><strong>属性合并</strong>：如果一个注解在继承链上多次出现，或者通过不同的元注解多次指定，Spring 需要确定哪些属性值将被采用。通常，更具体的定义（如在子类上的定义）会覆盖更一般的定义（如在父类上的定义）。</li>
<li><strong>属性别名处理</strong>：在注解定义中，可以通过 <code>@AliasFor</code> 指明属性别名，表明两个属性是等价的。在处理合并时，Spring 会确保别名之间的一致性，如果一个属性被设置了，它的别名也会相应地被设置。</li>
<li><strong>最终合成</strong>：通过上述步骤，Spring 构建了一个包含了所有合并逻辑的注解视图。最后，这个合并后的注解可以被应用于目标对象（如 Bean 定义），影响其行为。</li>
</ol>
<p>目前来看意义在于灵活处理注解继承关系、元注解信息、多个注解同时使用怎么处理</p>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="1-核心类"><a href="#1-核心类" class="headerlink" title="1. 核心类"></a>1. 核心类</h2><p><img src="https://camo.githubusercontent.com/4450d885fb5a5513c38f36b5174e8ff51ae1de8f4ee36dda8afbd043b907efc5/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3230352f3638312f323035363831333532332d356663333565623363643036635f61727469636c6578" alt="image-HandlerInterceptor"></p>
<p><code>HandlerInterceptor</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了拦截和处理http请求前置、后置及完成后的操作的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在实际的处理器(Controller)被调用之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 表示当前被拦截的处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true正常执行，false停止后续执行，自己处理响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在处理器(Controller)执行之后、生成试图之前调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 表示当前被拦截的处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView 表示处理器返回的ModelAndView对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在整个请求处理完毕之后调用，及在视图渲染完毕后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MappedInterceptor</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于精确控制拦截器的激活</span></span><br><span class="line"><span class="comment"> * MappedInterceptor不直接处理拦截任务，而是将请求委托给另一个HandlerInterceptor实例</span></span><br><span class="line"><span class="comment"> * MappedInterceptor本身主要负责决定是否执行拦截，实际的拦截逻辑由委托的HandlerInterceptor完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义了哪些url模式应该被拦截器处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; includePatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义了哪些url模式应该从拦截器处理中排除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; excludePatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存储被MappedInterceptor封装的拦截器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收一个HandlerInterceptor对象，用于后续的请求处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MappedInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptor = interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HandlerInterceptor <span class="title function_">getInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加支持的path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patterns</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MappedInterceptor <span class="title function_">addIncludePatterns</span><span class="params">(String... patterns)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.includePatterns.addAll(Arrays.asList(patterns));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加排除的path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patterns</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MappedInterceptor <span class="title function_">addExcludePatterns</span><span class="params">(String... patterns)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.excludePatterns.addAll(Arrays.asList(patterns));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * path匹配逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lookupPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String lookupPath)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先检查url在不在排除列表中</span></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.excludePatterns)) &#123;</span><br><span class="line">            <span class="comment">// 如果url在排除列表中，则不启用拦截器</span></span><br><span class="line">            <span class="keyword">if</span> (excludePatterns.contains(lookupPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 如果不在排除列表中</span></span><br><span class="line">        <span class="comment">// a. 检查包含列表，若为空，则拦截所有路径</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(<span class="built_in">this</span>.includePatterns)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b. 不为空，那就拦截包含列表中的路径</span></span><br><span class="line">        <span class="keyword">if</span> (includePatterns.contains(lookupPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c. 剩下的都放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interceptor.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptor.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptor.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InterceptorRegistry</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MappedInterceptor&gt; mappedInterceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册一个拦截器到Registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MappedInterceptor <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappedInterceptor</span>(interceptor);</span><br><span class="line">        mappedInterceptors.add(mappedInterceptor);</span><br><span class="line">        <span class="keyword">return</span> mappedInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;MappedInterceptor&gt; <span class="title function_">getMappedInterceptors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedInterceptors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-代理模式（静态代理）"><a href="#2-代理模式（静态代理）" class="headerlink" title="2. 代理模式（静态代理）"></a>2. 代理模式（静态代理）</h2><h3 id="2-1-关系"><a href="#2-1-关系" class="headerlink" title="2.1 关系"></a>2.1 关系</h3><p>代理类 <code>MappedInterceptor</code>持有一个真实对象的引用 <code>interceptor</code>（开发者自己实现的拦截器），并可以在调用真实对象的方法前后执行额外的操作。</p>
<h3 id="2-2-设计的核心目的"><a href="#2-2-设计的核心目的" class="headerlink" title="2.2 设计的核心目的"></a>2.2 设计的核心目的</h3><p>控制对另一个拦截器的访问，基于URL模式的匹配结果来决定是否调用实际拦截器的方法。这种行为是典型的代理模式应用。</p>
<h3 id="2-3-代理模式特点的体现"><a href="#2-3-代理模式特点的体现" class="headerlink" title="2.3 代理模式特点的体现"></a>2.3 代理模式特点的体现</h3><ol>
<li>在原本对象的基础上增加额外：控制访问，前置条件检查</li>
<li>不改变接口：在外部看来仍然是一个拦截器，与代理模式定义相符</li>
</ol>
<p>隐含策略模式</p>
<p>将url匹配逻辑封装为可配置的策略，自动根据不同的需求匹配拦截策略</p>
<h1 id="处理器映射器-返回处理器链对象"><a href="#处理器映射器-返回处理器链对象" class="headerlink" title="处理器映射器-返回处理器链对象"></a>处理器映射器-返回处理器链对象</h1><p><code>HandlerMapping</code>获取对应的 <code>Handler</code></p>
<p><img src="https://camo.githubusercontent.com/ea551f1d689c2d267a96a7b6fc9898633f7ce12e950d2af6c55c848a9c85c66b/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3339342f3231302f333934323130353736322d356663336161616133323737655f61727469636c6578" alt="image-Handler-Mapping---Handler"></p>
<p><code>HandlerExecutionChain</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理http请求的方法，封装在HandlerMethod对象中</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethod handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当时执行的拦截器索引，用于在请求处理过程中跟踪拦截器的执行位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">interceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 封装程序方法的类，用来执行程序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptors 拦截器列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerExecutionChain</span><span class="params">(HandlerMethod handler, List&lt;HandlerInterceptor&gt; interceptors)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历拦截器列表执行每个拦截器的perHandle方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.size(); i++) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * **逆序**遍历拦截器列表执行每个拦截器的postHandle方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(i);</span><br><span class="line">            interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆序遍历并调用每个拦截器的afterCompletion方法</span></span><br><span class="line"><span class="comment">     * afterCompletion，后续处理，在整个请求处理完毕之后调用，及在视图渲染完毕后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(i);</span><br><span class="line">            interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;HandlerInterceptor&gt; <span class="title function_">getInterceptors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HandlerMethod <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-拦截器执行顺序"><a href="#1-拦截器执行顺序" class="headerlink" title="1. 拦截器执行顺序"></a>1. <a href="https://hezhengdong.github.io/2024/04/15/Spring/SpringMVC/#3-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">拦截器执行顺序</a></h2><p>这些行为的设计主要基于Spring MVC拦截器的逻辑执行流程，旨在确保资源的正确管理和对请求处理的精确控制。以下是详细解释：</p>
<h3 id="1-1-为什么多个拦截器的三个方法（preHandle-postHandle-afterCompletion）要以特定的顺序执行？"><a href="#1-1-为什么多个拦截器的三个方法（preHandle-postHandle-afterCompletion）要以特定的顺序执行？" class="headerlink" title="1.1 为什么多个拦截器的三个方法（preHandle, postHandle, afterCompletion）要以特定的顺序执行？"></a>1.1 为什么多个拦截器的三个方法（<code>preHandle</code>, <code>postHandle</code>, <code>afterCompletion</code>）要以特定的顺序执行？</h3><ul>
<li><strong><code>preHandle</code> 方法</strong>：在控制器（Controller）方法处理之前执行。这是预处理请求的阶段，拦截器可以决定是否继续执行处理链（即继续调用其他拦截器或最终的处理器）。如果任何一个 <code>preHandle</code> 方法返回 <code>false</code>，则整个请求处理流程会立即停止，这允许拦截器阻止进一步的处理，比如在用户未授权访问特定资源时。</li>
<li><strong><code>postHandle</code> 方法</strong>：仅当所有的 <code>preHandle</code> 方法返回 <code>true</code>，即请求已被完全处理且未被任何拦截器拦截时，<code>postHandle</code> 方法才会被执行。它在控制器方法执行完毕后、视图渲染之前执行，用于修改或增加模型数据等后处理操作。</li>
<li><strong><code>afterCompletion</code> 方法</strong>：无论请求处理的结果如何，都将执行（即使有异常抛出）。这在处理链中的最后阶段执行，通常用于清理资源，如在请求开始时打开的资源。</li>
</ul>
<h3 id="1-2-为什么当-preHandle-方法返回-false-后，会跳过所有-postHandle-方法的执行？"><a href="#1-2-为什么当-preHandle-方法返回-false-后，会跳过所有-postHandle-方法的执行？" class="headerlink" title="1.2 为什么当 preHandle 方法返回 false 后，会跳过所有 postHandle 方法的执行？"></a>1.2 为什么当 <code>preHandle</code> 方法返回 <code>false</code> 后，会跳过所有 <code>postHandle</code> 方法的执行？</h3><p>当 <code>preHandle</code> 方法返回 <code>false</code>：</p>
<ul>
<li>表示拦截器已经确定后续的处理器方法不应继续执行，可能是因为用户未通过身份验证、请求数据不符合要求等原因。</li>
<li>跳过后续的所有处理器以及它们的 <code>postHandle</code> 方法执行是为了阻止进一步处理请求，因为后续步骤依赖于前面步骤的成功完成。继续执行 <code>postHandle</code> 可能会引起不一致的状态，因为 <code>postHandle</code> 方法通常假定 <code>preHandle</code> 已经成功执行并进行了相应的处理。</li>
<li>跳过 <code>postHandle</code> 后直接执行 <code>afterCompletion</code> 方法，是因为尽管请求没有被完全处理，但可能需要执行某些清理工作，这是 <code>afterCompletion</code> 方法的设计目的。</li>
</ul>
<p>这种设计模式确保了请求处理的一致性和预测性，使开发者能够在不同阶段精确控制请求的处理行为，同时在出现问题时能够及时中断请求处理，避免不必要的处理开销和潜在的错误。</p>
<h2 id="2-getHandler-方法"><a href="#2-getHandler-方法" class="headerlink" title="2. getHandler()方法"></a>2. getHandler()方法</h2><p>此方法主要负责根据传入的请求（通常是一个 <code>HttpServletRequest</code> 对象），找到对应的处理器（handler）。这个处理器通常是一个标有 <code>@RequestMapping</code> 注解的方法，如果找到匹配的处理器，它会返回一个 <code>HandlerExecutionChain</code> 对象。</p>
<p>总之，该方法是用于查找和返回处理特定请求所需的全部信息（包括处理器和拦截器）的复杂过程。</p>
<p><code>HandlerMapping</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于将客户端发起的 HTTP 请求映射到处理该请求的处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的 HttpServletRequest 对象获取相应的处理程序执行链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 给定的 HttpServletRequest 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取相应的处理程序执行链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RequestMappingHandlerMapping</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截器对象列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MappedInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 外部代码设置拦截器列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInterceptors</span><span class="params">(List&lt;MappedInterceptor&gt; interceptors)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的 HttpServletRequest 对象获取相应的处理程序执行链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request 给定的 HttpServletRequest 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 获取相应的处理程序执行链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取到本次请求的path</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="comment">// 根据path从MappingRegistry中找到对应的HandlerMethod</span></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handler</span> <span class="operator">=</span> mappingRegistry.getHandlerMethodByPath(lookupPath);</span><br><span class="line">    <span class="comment">// 找不到的话抛出NoHandlerFoundException异常</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(handler)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoHandlerFoundException</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了处理方法，则创建处理执行链（包含处理方法和HandlerExecutionChain）</span></span><br><span class="line">    <span class="keyword">return</span> createHandlerExecutionChain(lookupPath, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建处理执行链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lookupPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> HandlerExecutionChain <span class="title function_">createHandlerExecutionChain</span><span class="params">(String lookupPath, HandlerMethod handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 筛选出与当前请求路径匹配的拦截器</span></span><br><span class="line">    List&lt;HandlerInterceptor&gt; interceptors = <span class="built_in">this</span>.interceptors.stream()</span><br><span class="line">            .filter(mappedInterceptor -&gt; mappedInterceptor.matches(lookupPath))</span><br><span class="line">            .collect(toList());</span><br><span class="line">    <span class="comment">// 调用构造函数创建一个执行链实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler, interceptors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有两个异常类</p>
<p><code>ServletException</code></p>
<p><code>NoHandlerFoundException</code></p>
<h2 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3. Handler"></a>3. Handler</h2><p>Handler:处理程序</p>
<h3 id="3-1-Spring-MVC中的Handler"><a href="#3-1-Spring-MVC中的Handler" class="headerlink" title="3.1 Spring MVC中的Handler"></a>3.1 Spring MVC中的Handler</h3><p>在Spring MVC框架中，一个Handler通常指代一个处理HTTP请求的方法（即控制器方法）。这个方法能够接收请求、处理业务逻辑，并返回响应。</p>
<p>Spring MVC使用“Controller”这一术语来描述包含一个或多个Handler方法的类。</p>
<p>每个Handler方法通过注解（如 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code> 等）与一个特定的HTTP请求路径或动作关联。</p>
<h3 id="3-2-Handler的职责"><a href="#3-2-Handler的职责" class="headerlink" title="3.2 Handler的职责"></a>3.2 Handler的职责</h3><p>Handler的基本职责是接收HTTP请求，执行适当的业务逻辑处理，并返回适当的响应。响应可以是HTML页面、JSON数据、XML数据等，依据应用程序的需求而定。</p>
<h3 id="3-3-Handler与其他组件的交互"><a href="#3-3-Handler与其他组件的交互" class="headerlink" title="3.3 Handler与其他组件的交互"></a>3.3 Handler与其他组件的交互</h3><p>在Spring MVC架构中，Handler通常不单独工作。它们是多个组件交互的一部分，其中包括：</p>
<ul>
<li><strong>DispatcherServlet</strong>：作为前端控制器，它负责接收所有请求并将它们分派到相应的Handler。</li>
<li><strong>HandlerMapping</strong>：决定哪个Handler应当处理一个给定的请求。</li>
<li><strong>HandlerAdapter</strong>：帮助DispatcherServlet调用Handler方法。</li>
<li><strong>ViewResolver</strong>：帮助解析Handler返回的视图名到具体的视图（如JSP）。</li>
<li><strong>Interceptors</strong>：提供了一种机制，允许在处理请求之前和之后（甚至完成之后）执行特定的代码。</li>
<li><strong>HandlerExecutionChain</strong>：主要作用是为请求处理提供了一个包含Handler和所有应用到这个Handler的拦截器的容器（执行链）。这样，<code>DispatcherServlet</code> 可以按顺序执行所有相关的拦截器逻辑和最终的Handler方法。</li>
</ul>
<p>通过这些组件的协作，Spring MVC可以灵活地处理各种HTTP请求，同时提供清晰的业务逻辑分离和资源管理。</p>
<h1 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h1><p><img src="https://camo.githubusercontent.com/c867d80a0f5ef1f6b6f0955836b1275a134851d54d961718f198d0dcb3cd1e72/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3831392f3032372f3831393032373638382d356663626132653432356232315f61727469636c6578" alt="image-minispringmvc5"></p>
<h2 id="1-组成组件-1"><a href="#1-组成组件-1" class="headerlink" title="1. 组成组件"></a>1. 组成组件</h2><p><code>HttpServletRequest</code>，封装HTTP请求报文</p>
<p><code>HttpServletResponse</code>，封装HTTP响应报文</p>
<p><code>Model</code>，用于在控制器和视图之间传递数据，适用于MVC模式下的数据传递和视图渲染</p>
<blockquote>
<p><code>Model</code>是一个在控制器和视图之间传递数据的容器，扮演桥梁的角色，用于存储控制器产生的数据，这些数据最终会被传递到视图层，并在视图层中被渲染到最终的HTML中。<code>Model</code>本身只是作为数据的中介，不直接参与HTTP报文的构成。</p>
</blockquote>
<p>用到的注解</p>
<ol>
<li><p><code>@RequestParam</code></p>
<p>此注解用在请求handler方法的参数上，用于将http请求参数的值绑定到参数上。</p>
</li>
<li><p><code>@RequestBody</code></p>
<p>此注解用在请求handler方法的参数上，用于将http请求的Body映射绑定到此参数上。<code>HttpMessageConverter</code>负责将对象转换为http请求。</p>
</li>
</ol>
<p>Spring MVC的参数解析机制</p>
<ol>
<li><p><code>HandlerMethodArgumentResolver</code>接口</p>
<p>定义了处理器方法参数解析器的基本合同</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于解析控制器方法参数</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;负责从HTTP请求中提取数据，并将其转换为控制器方法参数所需的形式</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;通过实现此接口，开发者可以控制如何从HTTP请求中提取数据并转换成控制器方法所需要的参数类型，增加了框架的灵活性和强大的扩展能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法用于判断当前的实现是否支持给定的控制器方法参数。每个参数解析器可能只处理特定类型或具有特定注解的参数。例如，一个专门处理带有 <span class="doctag">@RequestParam</span> 注解的参数的解析器将会检查传入的 MethodParameter 是否具有该注解。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 对控制器方法中一个参数的封装，包括参数的类型、泛型信息、注解等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  如果这个解析器能处理传入的参数，返回 true；否则，返回 false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责实际解析HTTP请求，并返回转换后的参数值，该值将用于控制器方法的调用。</span></span><br><span class="line"><span class="comment">     * 这个过程可能涉及从请求中提取数据、数据类型转换、以及应用自定义的业务逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 控制器方法中的参数描述。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 当前的HTTP请求对象，包含了请求的URL、参数、头信息等。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 当前的HTTP响应对象，可以用于设置响应的状态码、头信息等。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> container 一个容器对象，用于在解析过程中存储模型数据或控制视图的渲染。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversionService 一个类型转换服务，用于将请求中的字符串类型数据转换为方法参数所需的具体类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析后的参数值，将直接传递给控制器方法。该值将用于控制器方法的调用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, HttpServletRequest request,</span></span><br><span class="line"><span class="params">                           HttpServletResponse response, ModelAndViewContainer container,</span></span><br><span class="line"><span class="params">                           ConversionService conversionService)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>ServletRequestMethodArgumentResolver</code></p>
<p>专门解析 <code>HttpServletRequest</code>类型的参数</p>
</li>
<li><p><code>ServletResponseMethodArgumentResolver</code></p>
<p>专门解析 <code>HttpServletResponse</code>类型的参数</p>
</li>
<li><p><code>ModelMethodArgumentResolver</code></p>
<p>用于解析 <code>Model</code>类型的参数。</p>
</li>
<li><p><code>RequestParamMethodArgumentResolver</code></p>
<p>用于解析带有 <code>@RequestParam</code>注解的方法参数。它可以从请求参数中提取值并将其转换为方法参数的类型。这个解析器支持基本类型、复杂对象和带默认值的参数。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer container,</span></span><br><span class="line"><span class="params">                              ConversionService conversionService)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 获取注解信息</span></span><br><span class="line">    <span class="type">RequestParam</span> <span class="variable">param</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 从请求中提取参数值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> request.getParameter(param.name());</span><br><span class="line">    <span class="comment">// 3. 如果请求中没有提供值，那么使用默认值</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        value = param.defaultValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 如果成功获取到值，使用ConversionService将字符串值转换为方法参数所需的类型</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> conversionService.convert(value, parameter.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 如果参数必须且值为空（且无默认值），则抛出MissingServletRequestParameterException异常</span></span><br><span class="line">    <span class="keyword">if</span> (param.required()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingServletRequestParameterException</span>(parameter.getParameterName(),</span><br><span class="line">                parameter.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p><code>RequestBodyMethodArgumentResolver</code></p>
<p>用于解析带有 <code>@RequestBody</code>注解的方法参数。它从请求体中读取数据并将其转换为方法参数的类型。这个解析器通常用于处理JSON或XML格式的请求体。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer container,</span></span><br><span class="line"><span class="params">                              ConversionService conversionService)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 获取字符串类型的HTTP请求体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">httpMessageBody</span> <span class="operator">=</span> <span class="built_in">this</span>.getHttpMessageBody(request);</span><br><span class="line">    <span class="comment">// 2. 使用FastJSON将请求体解析为指定参数类型的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(httpMessageBody)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(httpMessageBody, parameter.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 获取参数上的@RequestBody注解，检查注解是否存在&amp;必须，必须且不存在，抛出MissingServletRequestParameterException异常</span></span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestBody.class);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(requestBody)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestBody.required()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingServletRequestParameterException</span>(parameter.getParameterName(),</span><br><span class="line">                parameter.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getHttpMessageBody</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 用于构建请求体字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 获取请求体的读取器</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> request.getReader();</span><br><span class="line">    <span class="comment">// 读取请求体内容并将其追加到StringBuilder中，最后返回整个请求体字符串</span></span><br><span class="line">    <span class="type">char</span>[] buff = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = reader.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append(buff, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p><code>HandlerMethodArgumentResolverComposite</code></p>
<p>复合类，用于存储和管理多个 <code>HandlerMethodArgumentResolver</code>实例。它允许将多个解析器组合在一起，并根据参数类型或注解自动选择合适的解析器来处理参数。（策略模式）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存储多个HandlerMethodArgumentResolver实例，使该类管理和使用多个解析器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析参数方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer container, ConversionService conversionService)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 遍历argumentResolvers列表中的所有解析器</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : argumentResolvers) &#123;</span><br><span class="line">        <span class="comment">// 2. 调用每个解析器的supportsParameter方法检查其是否支持当前参数</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="comment">// 3. 如果支持，则调用该解析器的resolveArgument方法来解析参数并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> resolver.resolveArgument(parameter, request, response, container, conversionService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 如果没有任何解析器支持该参数，则抛出非法参数异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported parameter type [&quot;</span> +</span><br><span class="line">            parameter.getParameterType().getName() + <span class="string">&quot;]. supportsParameter should be called first.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-前后端对接过程"><a href="#2-前后端对接过程" class="headerlink" title="2. 前后端对接过程"></a>2. 前后端对接过程</h2><p>在Spring MVC等服务器端渲染的Web应用框架中，视图层是位于服务器端的一部分。这里的视图层不是指前端的HTML、CSS或JavaScript文件（虽然它们最终会生成这些内容），而是指用于生成HTML页面的模板和逻辑。这些模板使用服务器端存储的数据来渲染最终的HTML内容，然后这个内容通过HTTP响应发送给客户端。整个过程可以这样描述：</p>
<h3 id="2-1-过程详解"><a href="#2-1-过程详解" class="headerlink" title="2.1 过程详解"></a>2.1 过程详解</h3><ol>
<li><strong>用户交互</strong>：用户在浏览器中发起一个请求，比如点击一个链接或提交一个表单。</li>
<li><strong>HTTP请求</strong>：这个请求以HTTP报文的形式发送到服务器。</li>
<li><strong>控制器处理</strong>：服务器的Spring MVC框架接收到这个HTTP请求，并根据路由信息将请求分派到相应的控制器方法。</li>
<li><strong>数据处理与Model填充</strong>：控制器执行相应的业务逻辑（如数据库查询等），并将结果数据填充到Model对象中。</li>
<li><strong>视图渲染</strong>：控制器返回一个视图名称，根据这个名称，Spring MVC找到相应的视图模板。视图模板使用Model中的数据来渲染生成HTML内容。</li>
<li><strong>HttpServletResponse处理</strong>：生成的HTML内容通过 <code>HttpServletResponse</code>对象写入响应体。此外，<code>HttpServletResponse</code>还用于设置HTTP响应的其他部分，如状态码、响应头等。</li>
<li><strong>发送HTTP响应</strong>：完整的HTTP响应（包括HTML内容和响应头等）发送回客户端（浏览器）。</li>
<li><strong>客户端渲染</strong>：浏览器接收到HTTP响应后，解析HTML内容并呈现给用户。</li>
</ol>
<h3 id="2-2-重要的点"><a href="#2-2-重要的点" class="headerlink" title="2.2 重要的点"></a>2.2 重要的点</h3><ul>
<li><strong>视图是后端的一部分</strong>：在这种架构中，视图（即视图模板）完全运行在服务器上，与传统意义上运行在浏览器中的“前端代码”不同。</li>
<li><strong>生成的HTML是通过HTTP响应传送的</strong>：最终生成的HTML页面是作为HTTP响应的一部分发送给客户端的，这个过程由 <code>HttpServletResponse</code>控制。</li>
<li><strong>服务器端渲染</strong>：这种模式被称为服务器端渲染（SSR），即页面的内容在服务器上生成，然后作为静态HTML发送到客户端。</li>
</ul>
<p>这种设计模式使得服务器可以控制页面内容的生成，同时减少了客户端的计算负担，因为浏览器只负责显示最终的HTML内容。</p>
<h1 id="返回值处理器"><a href="#返回值处理器" class="headerlink" title="返回值处理器"></a>返回值处理器</h1><h2 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1. 实现方式"></a>1. 实现方式</h2><p><strong><code>HandlerMethodReturnValueHandler</code>返回值处理器顶层接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查该返回值处理器是否支持特定返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理控制器方法返回值的具体步骤</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnValue 实际返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType 返回值描述（类型、泛型信息、注解等）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mavContainer 一个容器对象，用于在处理过程中存储模型数据或控制视图的渲染</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request HTTP请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HTTP响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                           ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                           HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五个常用的返回值处理器，支持Handler返回 <code>Map</code>、<code> Modle</code>、 <code>View</code>、 <code>ViewName</code>以及被 <code>@ResponseBody</code>标注</strong></p>
<p>主要处理 <code>ModelAndView</code>的Model部分</p>
<ol>
<li><code>ModelMethodReturnValueHandler</code>，用于处理返回值类型为Model的控制器方法</li>
<li><code>MapMethodReturnValueHandler</code>，用于处理返回值类型为Map的控制器方法</li>
</ol>
<p>主要处理 <code>ModelAndView</code>的View部分，分别返回视图名和视图对象</p>
<ul>
<li><code>View</code>视图对象接口</li>
</ul>
<ol start="3">
<li><code>ViewNameMethodReturnValueHandler</code>，用于处理返回值类型为 <code>CharSequence</code>的控制器方法</li>
<li>&#96;&#96;ViewMethodReturnValueHandler&#96;，用于处理返回值类型为View的控制器方法</li>
</ol>
<p>用于将方法的返回对象直接输出到HTTP响应中</p>
<ul>
<li><code>@ResponseBody</code>注解</li>
</ul>
<ol start="5">
<li><code>ResponseBodyMethodReturnValueHandler</code>，用于处理被 <code>@ResponseBody</code>注解标注的控制器方法</li>
</ol>
<p>五个返回值解析器的<strong>具体实现</strong>大同小异</p>
<ul>
<li><p>相同：都是实现返回值解析器接口，先检查是否为指定类型，再转换属性</p>
</li>
<li><p>不同：</p>
<ul>
<li>前四个都是将获得的值添加到 <code>ModelAndView</code>容器当中，以便在视图渲染时使用，</li>
<li><code>@Response</code>是直接将对象转换为JSON并直接写入响应体中，并标记本次请求已经处理完成，之后不再需要进一步的模型视图解析。</li>
</ul>
</li>
</ul>
<p><strong><code>HandlerMethodReturnValueHandlerComposite</code>返回值处理器聚合类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储多个返回值处理器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有注册的返回值处理器，尝试找到一个支持当前返回值类型的处理器，并使用对应处理器处理返回值</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                              HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : returnValueHandlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">            handler.handleReturnValue(returnValue, returnType, mavContainer, request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported parameter type [&quot;</span> +</span><br><span class="line">            returnType.getParameterType().getName() + <span class="string">&quot;]. supportsParameter should be called first.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-补充"><a href="#2-补充" class="headerlink" title="2. 补充"></a>2. 补充</h2><p><code>CharSequence</code> 是 Java 中的一个一个表示字符序列的接口，提供了访问字符序列的基本方法。这个接口是 Java 中所有字符序列类的超类，常见的实现类包括 <code>String</code>、<code>StringBuilder</code> 和 <code>StringBuffer</code>。它提供了一些方法来访问和操作字符序列，但并没有规定具体的存储方式或实现细节，这些方法被它的所有实现类所实现。</p>
<p>常见实现类：</p>
<ul>
<li><strong>String</strong>：不可变的字符序列，一旦创建就不能修改。</li>
<li><strong>StringBuilder</strong>：可变的字符序列，适用于需要频繁修改字符内容的情况。<code>StringBuilder</code> 是线程不安全的。</li>
<li><strong>StringBuffer</strong>：可变的字符序列，与 <code>StringBuilder</code> 类似，但它是线程安全的，适用于多线程环境。</li>
</ul>
<h1 id="Handler执行器"><a href="#Handler执行器" class="headerlink" title="Handler执行器"></a>Handler执行器</h1><h2 id="1-InvocableHandlerMethod"><a href="#1-InvocableHandlerMethod" class="headerlink" title="1. InvocableHandlerMethod"></a>1. InvocableHandlerMethod</h2><p><code>InvocableHandlerMethod</code> 提供了一个集成点，它将请求处理流程中的参数解析、方法调用和返回值处理结合起来，确保通过统一的方式进行处理。</p>
<p><code>&lt;span style=&quot;color:red&quot;&gt;</code>可以说是一个包装器，”用于调用与 HTTP 请求相对应的方法，并处理方法的输入参数和返回值”将这些步骤包装起来，通过这个类的调用实现自动装配！</p>
<p>目前感觉类中的 <code>invokeAndHandle()</code>方法是最重要的，相当于 <code>doCreateBean()</code>和 <code>refresh()</code>方法的作用。</p>
<p>代码如下，核心类，结合注释好好看一遍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocableHandlerMethod</span> <span class="keyword">extends</span> <span class="title class_">HandlerMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数名称发现器，用于发现方法参数的名称，有助于绑定请求参数到方法参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ParameterNameDiscoverer</span> <span class="variable">parameterNameDiscoverer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数解析器，解析方法参数</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值解析器，处理方法返回值</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换服务</span></span><br><span class="line">    <span class="keyword">private</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocableHandlerMethod</span><span class="params">(HandlerMethod handlerMethod,</span></span><br><span class="line"><span class="params">                                  HandlerMethodArgumentResolverComposite argumentResolver,</span></span><br><span class="line"><span class="params">                                  HandlerMethodReturnValueHandlerComposite returnValueHandler,</span></span><br><span class="line"><span class="params">                                  ConversionService conversionService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(handlerMethod);</span><br><span class="line">        <span class="built_in">this</span>.argumentResolver = argumentResolver;</span><br><span class="line">        <span class="built_in">this</span>.returnValueHandler = returnValueHandler;</span><br><span class="line">        <span class="built_in">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用处理器方法并处理其返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mavContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                ModelAndViewContainer mavContainer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 解析方法参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 调用参数解析器解析方法参数，返回已经解析好的方法参数列表</span></span><br><span class="line">        List&lt;Object&gt; args = <span class="built_in">this</span>.getMethodArgumentValues(request, response, mavContainer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过反射执行目标控制器方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resultValue</span> <span class="operator">=</span> doInvoke(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回值为null</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(resultValue)) &#123;</span><br><span class="line">            <span class="comment">// 如果响应已经提交，标记容器已处理完成，否则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">                mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Controller handler return value is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回值非null，则继续处理返回值</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">        Assert.state(<span class="built_in">this</span>.returnValueHandler != <span class="literal">null</span>, <span class="string">&quot;No return value handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析方法返回值</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 创建MethodParameter实例(返回值信息（类型、泛型信息、注解等）)</span></span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">returnType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(<span class="built_in">this</span>.getMethod(), -<span class="number">1</span>);  <span class="comment">//-1表示方法的返回值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用返回值处理器处理返回值</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandler.handleReturnValue(resultValue, returnType, mavContainer, request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射直接执行对应的控制器方法</span></span><br><span class="line"><span class="comment">     * getMethod() 获取要调用的方法</span></span><br><span class="line"><span class="comment">     * getBean() 获取方法所在的实例</span></span><br><span class="line"><span class="comment">     * args.toArray() 将参数列表转换为数组形式</span></span><br><span class="line"><span class="comment">     * 返回值返回的就是控制器方法的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">doInvoke</span><span class="params">(List&lt;Object&gt; args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMethod().invoke(<span class="built_in">this</span>.getBean(), args.toArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用参数解析器解析方法参数，返回已经解析好的方法参数列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mavContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">getMethodArgumentValues</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                                 HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                                 ModelAndViewContainer mavContainer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.notNull(argumentResolver, <span class="string">&quot;HandlerMethodArgumentResolver can not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取方法参数的值列表</span></span><br><span class="line">        List&lt;MethodParameter&gt; parameters = <span class="built_in">this</span>.getParameters();</span><br><span class="line">        List&lt;Object&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parameters.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历方法的参数列表，逐个调用参数解析器来解析参数，并将解析结果添加到参数值列表中</span></span><br><span class="line">        <span class="keyword">for</span> (MethodParameter parameter : parameters) &#123;</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args.add(argumentResolver.resolveArgument(parameter, request, response, mavContainer, conversionService));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回解析好的参数值列表</span></span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameterNameDiscoverer</span><span class="params">(ParameterNameDiscoverer parameterNameDiscoverer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameterNameDiscoverer = parameterNameDiscoverer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ParameterNameDiscoverer"><a href="#2-ParameterNameDiscoverer" class="headerlink" title="2. ParameterNameDiscoverer"></a>2. ParameterNameDiscoverer</h2><p>正确的参数名称识别对于确保数据正确绑定到方法调用的参数上是至关重要的。</p>
<p>指定参数的映射时，如果没有准确的参数的名称，开发者可能需要依赖于参数的顺序或使用额外的注解来指定参数的映射，这可能会导致代码更加复杂且容易出错。因此，<code>ParameterNameDiscoverer</code> 是支持高效和精确自动装配及数据绑定功能的关键组件之一。</p>
<p>由于Java的反射API不能直接获取到方法参数的名称，所以该类底层提供了一系列的方法来确定方法参数的名称。</p>
<h3 id="2-1-底层实现"><a href="#2-1-底层实现" class="headerlink" title="2.1 底层实现"></a>2.1 底层实现</h3><p>（复制粘贴的，还只能看懂个大概，暂时先了解一下吧）</p>
<p>Spring 提供了几个 <code>ParameterNameDiscoverer</code> 的实现，每种实现使用不同的策略来确定方法参数的名称：</p>
<ol>
<li><strong>DefaultParameterNameDiscoverer</strong>: 这是一个复合实现，它按顺序尝试多个发现策略。默认情况下，它将尝试使用 <code>StandardReflectionParameterNameDiscoverer</code> 和 <code>LocalVariableTableParameterNameDiscoverer</code>。</li>
<li><strong>StandardReflectionParameterNameDiscoverer</strong>: 使用 Java 8 引入的反射能力，只在编译时使用了 <code>-parameters</code> 选项时才能获取参数名称。</li>
<li><strong>LocalVariableTableParameterNameDiscoverer</strong>: 通过读取类的字节码中的局部变量表来发现参数名称。这需要方法在编译时包含调试信息（通常是使用 <code>-g</code> 选项）。</li>
<li><strong>AspectJAdviceParameterNameDiscoverer</strong>: 特别用于处理 AspectJ 的通知（advice）方法，可以解析通知方法的参数名称。</li>
</ol>
<h3 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h3><p>尤其是在需要进行方法参数绑定的场景中</p>
<ul>
<li><p><code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>方法参数解析</strong>: 在 Spring MVC 中，控制器方法的参数需要从 HTTP 请求中解析并绑定，<code>ParameterNameDiscoverer</code> 能帮助解析器确定方法参数的具体名称，以便正确地从请求中提取相应的数据。</p>
</li>
<li><p><strong>数据绑定</strong>: 在需要将请求参数、路径变量或表单数据绑定到方法参数时，参数名称的正确识别是关键。</p>
</li>
<li><p><strong>Spring AOP</strong>: 在创建通知（advice）时，参数名称可能会用于与切点表达式进行匹配。</p>
<p>！！！AOP竟然也用到了，当时我是怎么实现的呢？</p>
</li>
</ul>
<h2 id="3-MethodParameter"><a href="#3-MethodParameter" class="headerlink" title="3. MethodParameter"></a>3. MethodParameter</h2><p>还能与数据绑定有关，不过目前用到的是参数解析、类型转换的作用</p>
<h3 id="3-1-表示方法参数信息"><a href="#3-1-表示方法参数信息" class="headerlink" title="3.1 表示方法参数信息"></a>3.1 表示方法参数信息</h3><p><code>MethodParameter</code>，通常用于表示方法参数的信息，<strong>提供了很多有用的方法来访问参数的元数据，例如参数类型、参数注解等</strong></p>
<p><strong>在参数解析器中扮演的作用</strong></p>
<ul>
<li>先是判断支持的参数，用的是 <code>parameter.hasParameterAnnotation(RequestBody.class)</code></li>
<li>然后 <code>JSON.parseObject</code>将json转换为java对象，参数中用到了 <code>MethodParameter</code>获得类型</li>
<li>获取注解实例用到了 <code>parameter.getParameterAnnotation</code></li>
<li>参数解析器<strong>new</strong> <code>MethodParameter</code>的时候</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMethod类 构造方法中</span></span><br><span class="line"><span class="built_in">this</span>.parameters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> method.getParameterCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; parameterCount; index++) &#123;</span><br><span class="line">    parameters.add(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(method, index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实例化 <code>MethodParameter</code>之前先复习一下 <code>HandlerMethod</code></p>
<p>一个 <code>HandlerMethod</code>对象封装的是一个 处理程序方法的类 中 对应控制器方法 的信息</p>
<p>四个参数</p>
<ol>
<li>控制器类bean</li>
<li>bean类型</li>
<li>对应控制器方法对象</li>
<li>方法参数对象列表</li>
</ol>
<p>然后index的作用的发挥出来了，用来标识方法参数的顺序，保证方法调用的时候参数按正确的顺序和类型被传递，确保精确度。</p>
<h3 id="3-2-表示方法返回值类型信息"><a href="#3-2-表示方法返回值类型信息" class="headerlink" title="3.2 表示方法返回值类型信息"></a>3.2 表示方法返回值类型信息</h3><p>通过特殊的方法使用，<code>MethodParameter</code>也能代表某个方法的返回类型，<strong>包括方法返回值的类型、泛型信息、以及任何可能存在的注解等元数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodParameter</span> <span class="variable">returnType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(<span class="built_in">this</span>.getMethod(), -<span class="number">1</span>); </span><br></pre></td></tr></table></figure>

<p>关键在于第二个参数-1，它在 <code>MethodParameter</code> 的上下文中用来特别指示这个 <code>MethodParameter</code> 实例是用来表示方法的返回类型，而不是一个特定的方法参数。</p>
<p><strong>在返回值解析器中扮演的作用</strong></p>
<ul>
<li><code>supportsReturnType</code>方法检查类型的时候用到</li>
<li>在抛异常的时候用到，打印了些参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Unexpected return type: &quot;</span> +</span><br><span class="line">        returnType.getParameterType().getName() + <span class="string">&quot; in method: &quot;</span> + returnType.getMethod());</span><br></pre></td></tr></table></figure>

<ul>
<li>当然，最重要的是<strong>new</strong> <code>MethodParameter</code>对象的时候</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocableHandlerMethod#invokeAndHandle</span></span><br><span class="line"><span class="comment">// 创建MethodParameter实例(返回值信息（类型、泛型信息、注解等）)</span></span><br><span class="line"><span class="type">MethodParameter</span> <span class="variable">returnType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(<span class="built_in">this</span>.getMethod(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 调用返回值处理器处理返回值</span></span><br><span class="line"><span class="built_in">this</span>.returnValueHandler.handleReturnValue(resultValue, returnType, mavContainer, request, response);</span><br></pre></td></tr></table></figure>

<h1 id="处理器适配器"><a href="#处理器适配器" class="headerlink" title="处理器适配器"></a>处理器适配器</h1><p>实现 <code>RequestMappingHandlerAdapter</code></p>
<h2 id="1-HandlerAdapter"><a href="#1-HandlerAdapter" class="headerlink" title="1. HandlerAdapter"></a>1. HandlerAdapter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;用于处理HTTP请求，并将请求映射到相应的处理器方法（即Controller方法）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;主要作用是将处理器方法（HandlerMethod）与实际的HTTP请求和响应关联起来，返回一个模型和视图对象</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;充当HTTP请求和SpringMVC处理器方法之间的桥梁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于定义如何处理一个HTTP请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request HTTP请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HTTP响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 处理当前请求的方法。它是一个封装了具体处理逻辑的方法，包含了该方法的所有相关信息，如方法参数、返回值类型、所属的Controller实例等。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ModelAndView容器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                        HandlerMethod handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-RequestMappingHandlerAdapter"><a href="#2-RequestMappingHandlerAdapter" class="headerlink" title="2. RequestMappingHandlerAdapter"></a>2. RequestMappingHandlerAdapter</h2><p>最常用的处理器适配器，相比于集成点对象，这里是<strong>实例化集成点对象</strong>的地方，通过初始化方法，初始化了集成点所需的各个参数，并将返回值转换为标准的 <code>ModelAndView</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多种处理器适配器中的一种，主要负责处理通过<span class="doctag">@RequestMapping</span>注解定义的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义参数解析器列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内嵌的复合参数解析器</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolverComposite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义返回值处理器列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内嵌的复合返回值处理器</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlerComposite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换服务</span></span><br><span class="line">    <span class="keyword">private</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义了如何处理一个HTTP请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建了一个集成点对象，里面的成员变量在初始化过程中被赋值</span></span><br><span class="line">        <span class="type">InvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建了一个ModelAndViewContainer对象</span></span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用invokeAndHandle方法，执行Controller方法，并将结果传递给ModelAndViewContainer对象</span></span><br><span class="line">        invocableMethod.invokeAndHandle(request, response, mavContainer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 根据返回的ModelAndViewContainer对象中的值，返回ModelAndView对象</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在属性设置完成后被调用，用于执行一些初始化操作</span></span><br><span class="line"><span class="comment">     * 初始化了参数解析器和返回值处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.notNull(conversionService, <span class="string">&quot;conversionService can not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(argumentResolverComposite)) &#123;</span><br><span class="line">            List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">            <span class="built_in">this</span>.argumentResolverComposite = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">            <span class="built_in">this</span>.argumentResolverComposite.addResolver(resolvers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(returnValueHandlerComposite)) &#123;</span><br><span class="line">            List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">            <span class="built_in">this</span>.returnValueHandlerComposite = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">            <span class="built_in">this</span>.returnValueHandlerComposite.addReturnValueHandler(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下都是些填充成员变量的方法，还有setter、getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-ModelAndView-ModelAndViewContainer"><a href="#3-ModelAndView-ModelAndViewContainer" class="headerlink" title="3. ModelAndView&amp;ModelAndViewContainer"></a>3. ModelAndView&amp;ModelAndViewContainer</h2><p><code>ModelAndView</code>和 <code>ModelAndViewContainer</code>的区别与关系</p>
<h3 id="3-1-ModelAndView"><a href="#3-1-ModelAndView" class="headerlink" title="3.1 ModelAndView"></a>3.1 ModelAndView</h3><p>主要用于封装模型数据和视图信息，承载了模型和视图的信息，以便后续渲染</p>
<h3 id="3-2-ModelAndViewContainer"><a href="#3-2-ModelAndViewContainer" class="headerlink" title="3.2 ModelAndViewContainer"></a>3.2 ModelAndViewContainer</h3><p>主要用于在请求处理的过程中<strong>管理模型数据</strong>和<strong>视图渲染的决策</strong></p>
<p>管理模型数据：就是封装模型数据和视图信息，和 <code>ModelAndView</code>一样</p>
<p>视图渲染的决策：例如管理请求处理状态，是否需要进一步渲染视图，主要在框架的内部使用，用于更好的自动管理模型数据和视图信息。</p>
<h1 id="视图的渲染"><a href="#视图的渲染" class="headerlink" title="视图的渲染"></a>视图的渲染</h1><p>主要涉及两种，重定向视图的渲染和JSP视图的渲染</p>
<p>白雪，已经淘汰啦！后端现在根本不用管视图怎么渲染，什么视图解析器！给前端返回数据就行了！就当是体会了一下技术的迭代吧。</p>
<h2 id="1-RedirectView"><a href="#1-RedirectView" class="headerlink" title="1. RedirectView"></a>1. RedirectView</h2><p>Spring MVC集成servlet后端重定向的方法。</p>
<p>不过在前后端分离的开发模式中，这种方式已经不是很常用了（虽然能用，重定向是可以重定向到项目外部资源的）</p>
<p>原因：随着单页面应用（SPA）和现代JavaScript框架（如React, Vue, Angular）的流行，前端更多地采用AJAX和API调用来管理数据和路由，而避免全页面的重载。在这种模式下，重定向通常是通过前端路由来处理，而非由后端HTTP重定向完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedirectView</span> <span class="keyword">extends</span> <span class="title class_">AbstractView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedirectView</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">renderMergedOutputModel</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> createTargetUrl(model, request);</span><br><span class="line">        response.sendRedirect(targetUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * model中的数据添加到URL后面作为参数</span></span><br><span class="line"><span class="comment">     * 按照HTTP规范，当服务器返回一个重定向响应后，客户端应该使用GET方法去请求在Location头部指定的URL，而不是继续使用POST方法。所以这里使用的是get方式拼接路径。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">createTargetUrl</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.url, <span class="string">&quot;url can not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">queryParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        model.forEach((key, value) -&gt; &#123;</span><br><span class="line">            queryParams.append(key).append(<span class="string">&quot;=&quot;</span>).append(value).append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (queryParams.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            queryParams.deleteCharAt(queryParams.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">targetUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.url.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// Do not apply context path to relative URLs.</span></span><br><span class="line">            targetUrl.append(getContextPath(request));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targetUrl.append(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queryParams.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            targetUrl.append(<span class="string">&quot;?&quot;</span>).append(queryParams.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> targetUrl.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContextPath</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        <span class="keyword">while</span> (contextPath.startsWith(<span class="string">&quot;//&quot;</span>)) &#123;</span><br><span class="line">            contextPath = contextPath.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-InternalResourceView"><a href="#2-InternalResourceView" class="headerlink" title="2. InternalResourceView"></a>2. InternalResourceView</h2><p>这属于传统的基于服务器的页面渲染方式了，在前后端分离的方式中已经被淘汰。</p>
<p>前后端分离通常意味着前端（如使用React, Angular, Vue等构建的应用）独立于后端，通过API（通常是REST API）与后端进行交互。前端负责所有的用户界面逻辑和展示，而后端则专注于数据处理和业务逻辑。在这种模式下，后端主要返回JSON或XML等格式的数据，而不是生成HTML页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring MVC框架中用于处理服务器内部资源（如JSP页面）转发的视图</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;总的来说，InternalResourceView 类提供了一种将控制器逻辑与 JSP 或其他服务器资源的视图层分离的方法，通过将模型数据暴露为请求属性，并将请求转发到服务器内部的具体资源。这种方式非常适用于传统的基于服务器的页面渲染方法，现已几乎被淘汰。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InternalResourceView</span> <span class="keyword">extends</span> <span class="title class_">AbstractView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InternalResourceView</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContentType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">renderMergedOutputModel</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将模型数据暴露给JSP或其他服务端资源</span></span><br><span class="line">        exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="built_in">this</span>.url);</span><br><span class="line">        rd.forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把model中的数据放入到request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exposeModelAsRequestAttributes</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> &#123;</span><br><span class="line">        model.forEach((name, value) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(value)) &#123;</span><br><span class="line">                request.setAttribute(name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                request.removeAttribute(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h1><p><img src="https://camo.githubusercontent.com/924c29712629e6c7084de54ff21a30064b6dda2765b79e83864b90ea3bd3c0d3/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f33303962633231613532383334393336616161323666323732323962393332657e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="image"></p>
<h2 id="1-ViewResolver接口"><a href="#1-ViewResolver接口" class="headerlink" title="1. ViewResolver接口"></a>1. ViewResolver接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line">    View <span class="title function_">resolveViewName</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-AbstractCachingViewResolver"><a href="#2-AbstractCachingViewResolver" class="headerlink" title="2. AbstractCachingViewResolver"></a>2. AbstractCachingViewResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于解析视图名称到具体的View实例的抽象类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;引入了缓存机制来提高视图解析的效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCachingViewResolver</span> <span class="keyword">implements</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个私有的锁对象，用于同步代码块，确保线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量，代表无法解析的视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">View</span> <span class="variable">UNRESOLVED_VIEW</span> <span class="operator">=</span> (model, request, response) -&gt; &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存，用于存储已解析的视图名称和对应的View实例</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, View&gt; cachedViews = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析ViewName为View对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> cachedViews.get(viewName);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(view)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 再次检查缓存（以防在等待锁的时间内其他线程已经缓存了视图）</span></span><br><span class="line">            view = cachedViews.get(viewName);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(view)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新的视图</span></span><br><span class="line">            view = createView(viewName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回null，代表视图无法解析，将UNRESOLVED_VIEW存入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(view)) &#123;</span><br><span class="line">                view = UNRESOLVED_VIEW;</span><br><span class="line">            &#125;</span><br><span class="line">            cachedViews.put(viewName, view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据视图名称创建View对象，负责具体的视图解析逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> View <span class="title function_">createView</span><span class="params">(String viewName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-UrlBasedViewResolver"><a href="#3-UrlBasedViewResolver" class="headerlink" title="3. UrlBasedViewResolver"></a>3. UrlBasedViewResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.view.resolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.view.InternalResourceView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.view.RedirectView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.view.View;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于解析基于URL的视图，包括重定向和转发操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UrlBasedViewResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractCachingViewResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量，用于定义视图名称的前缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIRECT_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;redirect:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORWARD_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;forward:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图名称的前后缀，用于构建最终的视图URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于根据ViewName创建具体的View实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> View <span class="title function_">createView</span><span class="params">(String viewName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查视图名称是否以特定的前缀开始，以确定是否需要执行重定向或转发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是重定向，创建RedirectView</span></span><br><span class="line">        <span class="keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedirectView</span>(redirectUrl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是转发，创建InternalResourceView</span></span><br><span class="line">        <span class="keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">forwardUrl</span> <span class="operator">=</span> viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InternalResourceView</span>(forwardUrl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果都不是，调用buildView方法解析视图</span></span><br><span class="line">        <span class="keyword">return</span> buildView(viewName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> View <span class="title function_">buildView</span><span class="params">(String viewName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrefix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuffix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuffix</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-InternalResourceViewResolver"><a href="#4-InternalResourceViewResolver" class="headerlink" title="4. InternalResourceViewResolver"></a>4. InternalResourceViewResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器内部资源视图（如JSP、HTML等）解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InternalResourceViewResolver</span> <span class="keyword">extends</span> <span class="title class_">UrlBasedViewResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> View <span class="title function_">buildView</span><span class="params">(String viewName)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> getPrefix() + viewName + getSuffix();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InternalResourceView</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-拼接前后缀"><a href="#5-拼接前后缀" class="headerlink" title="5. 拼接前后缀"></a>5. 拼接前后缀</h2><p>解析 <code>ViewName</code>主要分为两类</p>
<ol>
<li>请求转发和响应重定向</li>
<li>服务器内部资源视图解析器（解析服务器内部的JSP、HTML等）</li>
</ol>
<p><code>UrlBasedViewResolver</code>里定义了前缀后缀两个成员变量，请求转发和响应重定向是用不到的，解析内部视图的时候用到，如下：</p>
<p>这种设计使得 <code>InternalResourceViewResolver</code> 成为处理基于服务器的视图（如 JSP 或其他模板引擎页面）的理想选择。通过配置前缀和后缀，可以非常灵活地控制资源路径的解析，适应不同的部署环境或应用需求。例如，可以将前缀设置为 “&#x2F;WEB-INF&#x2F;views&#x2F;“，后缀设置为 “.jsp”，从而使得 <code>viewName</code> “home” 解析为 “&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp”，这对于在 MVC 应用中定位视图文件非常有用。</p>
<p><code>InternalResourceViewResolver</code> 提供了一种简单有效的方法来解析并转发到应用内部定义的资源，使得视图管理在 Spring MVC 应用中变得既清晰又高效。</p>
<h2 id="6-RequestContextHolder工具类"><a href="#6-RequestContextHolder工具类" class="headerlink" title="6. RequestContextHolder工具类"></a>6. RequestContextHolder工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用ThreadLocal机制，在当前线程中存储和访问HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RequestContextHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储HttpServletRequest对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HttpServletRequest&gt; inheritableRequestHolder =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NamedInheritableThreadLocal</span>&lt;&gt;(<span class="string">&quot;Request context&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置线程中的HttpServletRequest对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resetRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        inheritableRequestHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        inheritableRequestHolder.set(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpServletRequest <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inheritableRequestHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-ContentNegotiatingViewResolver"><a href="#7-ContentNegotiatingViewResolver" class="headerlink" title="7. ContentNegotiatingViewResolver"></a>7. ContentNegotiatingViewResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个集成了所有配置视图解析器的复合类，它通过内部的策略（基于内容协商）来选择最合适的视图解析器进行视图解析</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;本身充当管理者的角色，调度和协调其他视图解析器来根据请求的内容类型选择最合适的视图。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContentNegotiatingViewResolver</span> <span class="keyword">implements</span> <span class="title class_">ViewResolver</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含多个 ViewResolver 的列表，用于解析视图名称到具体的 View 实例</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含默认 View 实例的列表，这些视图可以用于在没有特定匹配时提供备选视图</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;View&gt; defaultViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有候选视图</span></span><br><span class="line">        List&lt;View&gt; candidateViews = getCandidateViews(viewName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择最佳视图</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">bestView</span> <span class="operator">=</span> getBestView(candidateViews);</span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(bestView))&#123;</span><br><span class="line">            <span class="keyword">return</span> bestView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有合适的视图，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据请求找出最优视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidateViews</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> View <span class="title function_">getBestView</span><span class="params">(List&lt;View&gt; candidateViews)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从候选视图中查找是否存在RedirectView类型的视图</span></span><br><span class="line">        Optional&lt;View&gt; viewOptional = candidateViews.stream()</span><br><span class="line">                .filter(view -&gt; view <span class="keyword">instanceof</span> RedirectView)</span><br><span class="line">                .findAny();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果RedirectView类型的视图存在，则优先返回该视图</span></span><br><span class="line">        <span class="keyword">if</span> (viewOptional.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> viewOptional.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从RequestContextHolder中获取当前请求</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> RequestContextHolder.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求中的Accept头部，Accept头部说明了客户端期望接收哪种内容类型</span></span><br><span class="line">        Enumeration&lt;String&gt; acceptHeaders = request.getHeaders(<span class="string">&quot;Accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环遍历Accept头部和候选视图，查找内容类型匹配的视图</span></span><br><span class="line">        <span class="keyword">while</span> (acceptHeaders.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (View view : candidateViews) &#123;</span><br><span class="line">                <span class="keyword">if</span> (acceptHeaders.nextElement().contains(view.getContentType())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先找出所有候选视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;View&gt; <span class="title function_">getCandidateViews</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化候选视图列表</span></span><br><span class="line">        List&lt;View&gt; candidateViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有视图解析器尝试解析视图</span></span><br><span class="line">        <span class="keyword">for</span> (ViewResolver viewResolver : viewResolvers) &#123;</span><br><span class="line">            <span class="comment">// 如果解析到了，那就将解析好的View对象存入视图列表当中</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> viewResolver.resolveViewName(viewName);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(view)) &#123;</span><br><span class="line">                candidateViews.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有默认视图并且视图列表不为空，则将默认视图也加入到候选视图列表中</span></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(defaultViews)) &#123;</span><br><span class="line">            candidateViews.addAll(defaultViews);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidateViews;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查ViewResolvers是否被正确设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.notNull(viewResolvers, <span class="string">&quot;viewResolvers can not null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置视图解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewResolvers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setViewResolvers</span><span class="params">(List&lt;ViewResolver&gt; viewResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.viewResolvers = viewResolvers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultViews</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultViews</span><span class="params">(List&lt;View&gt; defaultViews)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultViews = defaultViews;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p><img src="https://camo.githubusercontent.com/0ba1221a2d69b79c4cad16d3b2a77736f8adfe5b5fcd5f659871c502cf5e3af2/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f35613032373638383466316234613633626465653466623966333039363630377e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="image"></p>
<p>dispatcher：调度</p>
<p>核心类，充当前端控制器的角色，负责处理所有通过Spring应用的HTTP请求。</p>
<p><code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>主要职责是协调各种资源，完成对HTTP请求的调度分发</strong>，包括控制器（controllers）、视图解析器（view resolvers）、处理器映射（handler mappings）等，<code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>来处理请求和生成响应</strong>。</p>
<p>extends <code>HttpServlet</code> 使其可以处理 HTTP 请求和响应</p>
<p>implements <code>ApplicationContextAware</code> 允许它接入 Spring 容器，管理 Spring Bean</p>
<p>主要分为两部分</p>
<ul>
<li><p>一部分是借助 <code>GenericServlet</code>的 <code>init</code>初始化方法和对 <code>ApplicationContext</code>的感知，完成自身属性的初始化</p>
</li>
<li><p>另一部分就是协调各种资源，完成对HTTP请求的调度分发，处理请求、生成响应。</p>
<p>简要概述其工作流程如下：</p>
<ol>
<li><strong>请求接收</strong>：<code>DispatcherServlet</code> 接收到客户端发送的 HTTP 请求。</li>
<li><strong>请求解析</strong>：根据请求的 URL、HTTP 方法等信息，<code>DispatcherServlet</code> 使用合适的 <code>HandlerMapping</code> 查找并选择对应的处理器（Controller中的方法）。</li>
<li><strong>请求委托</strong>：一旦确定了处理器，<code>DispatcherServlet</code> 会调用相应的 <code>HandlerAdapter</code> 来执行处理器方法。</li>
<li><strong>模型与视图</strong>：处理器方法执行完成后，通常会返回一个 <code>ModelAndView</code> 对象，其中包含了模型数据和视图名称。</li>
<li><strong>视图渲染</strong>：根据返回的视图名称，<code>DispatcherServlet</code> 使用配置的 <code>ViewResolver</code> 来解析视图。解析后的 <code>View</code> 对象负责渲染模型数据，生成最终的页面。</li>
<li><strong>响应返回</strong>：渲染完的页面作为 HTTP 响应返回给客户端。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化日志记录器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用Spring应用上下文</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring MVC 处理请求的核心组件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的映射处理器。确定有那个控制器处理传入的请求</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMapping handlerMapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行处理器逻辑的适配器。调用处理器方法的适配器</span></span><br><span class="line">    <span class="keyword">private</span> HandlerAdapter handlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于解析视图名称到具体试图实现的解析器。解析视图名到具体的视图实现</span></span><br><span class="line">    <span class="keyword">private</span> ViewResolver viewResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理器集合。处理请求过程中出现的异常的解析器集合</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承自GenericServlet的init初始化方法，从Spring上下文中获取必要的组件，</span></span><br><span class="line"><span class="comment">     * 如处理器映射、处理器适配器、视图解析器和异常处理器集合，</span></span><br><span class="line"><span class="comment">     * 即HandlerMapping, HandlerAdapter, ViewResolver 和 HandlerExceptionResolver 的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerMapping = <span class="built_in">this</span>.applicationContext.getBean(HandlerMapping.class);</span><br><span class="line">        <span class="built_in">this</span>.handlerAdapter = <span class="built_in">this</span>.applicationContext.getBean(HandlerAdapter.class);</span><br><span class="line">        <span class="built_in">this</span>.viewResolver = <span class="built_in">this</span>.applicationContext.getBean(ViewResolver.class);</span><br><span class="line">        <span class="built_in">this</span>.handlerExceptionResolvers =</span><br><span class="line">                <span class="built_in">this</span>.applicationContext.getBeansOfType(HandlerExceptionResolver.class).values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于接收HTTP请求并调用doDispatch方法来分发请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request   the &#123;<span class="doctag">@link</span> HttpServletRequest&#125; object that</span></span><br><span class="line"><span class="comment">     *                  contains the request the client made of</span></span><br><span class="line"><span class="comment">     *                  the servlet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  the &#123;<span class="doctag">@link</span> HttpServletResponse&#125; object that</span></span><br><span class="line"><span class="comment">     *                  contains the response the servlet returns</span></span><br><span class="line"><span class="comment">     *                  to the client</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;DispatcherServlet.service =&gt; uri:&#123;&#125;&quot;</span>, request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前线程的请求上下文，使得在应用的任何地方都可以访问到当前的请求和响应对象</span></span><br><span class="line">        RequestContextHolder.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用doDispatch方法来分发请求</span></span><br><span class="line">            doDispatch(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Handler the request fail&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 请求结束后重置请求上下文，清理与当前线程关联的请求和响应对象</span></span><br><span class="line">            RequestContextHolder.resetRequest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分发请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录过程中发生的任何异常</span></span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于保存处理请求的处理器链</span></span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取与请求匹配的处理器链</span></span><br><span class="line">                executionChain = <span class="built_in">this</span>.handlerMapping.getHandler(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行处理器链中的预处理操作。如果预处理返回false，则直接返回不继续执行后续操作</span></span><br><span class="line">                <span class="keyword">if</span> (!executionChain.applyPreHandle(request, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实际调用处理器，实例化集成点对象的地方，实际处理了一个HTTP请求，返回ModelAndView对象</span></span><br><span class="line">                <span class="comment">// （这里集成了之前所有的参数解析器，返回值处理器，Handler执行器，集成点对象(从拦截器链中获取的)）</span></span><br><span class="line">                mv = handlerAdapter.handle(request, response, executionChain.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行拦截器链后处理操作</span></span><br><span class="line">                executionChain.applyPostHandle(request, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果内部处理器不能解决异常，或者由于某种原因重新抛出了异常，</span></span><br><span class="line"><span class="comment">                 * 那么这个异常就会被外部 try-catch 块捕获并再次抛出，</span></span><br><span class="line"><span class="comment">                 * 此时它将逃离 Spring 的处理流程，交由更上层的异常处理机制处理</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                dispatchException = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理分发结果，包括视图渲染和异常处理</span></span><br><span class="line">            processDispatchResult(request, response, mv, dispatchException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            dispatchException = ex;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行处理链的完成后处理方法，无论请求处理过程是否成功</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(executionChain)) &#123;</span><br><span class="line">                executionChain.triggerAfterCompletion(request, response, dispatchException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理分发结果，包括视图渲染和异常处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                       ModelAndView mv, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有异常发生，如果有，调用processHandlerException方法处理异常，该方法响应错误json数据或者返回一个错误页面的ModelAndView</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(ex)) &#123;</span><br><span class="line">            <span class="comment">//error ModelAndView</span></span><br><span class="line">            mv = processHandlerException(request, response, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查ModelAndView是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(mv)) &#123;</span><br><span class="line">            <span class="comment">// 如果不为null，则调用render方法渲染视图</span></span><br><span class="line">            render(mv, request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为null，记录日志，无视图被渲染</span></span><br><span class="line">        logger.info(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 渲染视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> mv.getViewName();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(viewName)) &#123;</span><br><span class="line">            view = <span class="built_in">this</span>.viewResolver.resolveViewName(viewName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = (View) mv.getView();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mv.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setStatus(mv.getStatus().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        view.render(mv.getModel().asMap(), request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现异常后的ModelAndView</span></span><br><span class="line">    <span class="keyword">private</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                                 Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(<span class="built_in">this</span>.handlerExceptionResolvers)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="built_in">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> resolver.resolveException(request, response, ex);</span><br><span class="line">            <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> exMv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到对应的异常处理器，就继续抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h1><p><code>&lt;span style=&quot;color:red&quot;&gt;</code><strong>终于看懂了，熟悉使用是看源码的前提！如果连它的作用都不知道是什么，那源码肯定看不懂！</strong></p>
<p><img src="https://camo.githubusercontent.com/5295c8c433270d3c141026b71a01e14131f021ebf307752d3bf35ce5bc87de51/68747470733a2f2f70392d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f30613864396166646462396434393861626232326635356362313233633465647e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="image"></p>
<p>先举一个全局异常处理器实际使用的例子，看源码时要集合这个例子想象Spring MVC底层是如何识别各个注解，如何根据异常信息自动识别执行对应异常处理方法，如何将异常处理方法当作正常的控制器方法执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">runtimeHandleException</span><span class="params">(RuntimeException e)</span>&#123;</span><br><span class="line">        <span class="comment">//模拟一个ResultInfo</span></span><br><span class="line">        <span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;RuntimeException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resultInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">ioHandleException</span><span class="params">(IOException e)</span>&#123;</span><br><span class="line">        <span class="comment">//模拟一个ResultInfo</span></span><br><span class="line">        <span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;IOException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resultInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-注解"><a href="#1-注解" class="headerlink" title="1. 注解"></a>1. 注解</h2><p><code>@ControllerAdvice</code></p>
<p>可以使用 <code>@ControllerAdvice</code>来声明一个类来统一对所有 <code>@RequestMapping</code>方法来做 <code>@ExceptionHandler</code>、<code>@InitBinder</code>以及 <code>@ModelAttribute</code>处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerAdvice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ExceptionHandler</code></p>
<p>使用全局异常处理器的方法上，声明对 <code>Exception</code>的处理逻辑。可以指定目标 <code>Exception</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ExceptionHandlerMethodResolver"><a href="#2-ExceptionHandlerMethodResolver" class="headerlink" title="2. ExceptionHandlerMethodResolver"></a>2. ExceptionHandlerMethodResolver</h2><p><code>ExceptionHandlerMethodResolver</code>的作用是封装全局异常处理器中定义的方法，建立异常类型与处理方法之间的映射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要作用：解析带有<span class="doctag">@ExceptionHandler</span>注解的处理异常的方法，并建立异常类型与处理方法之间的映射（就是封装全局异常处理器中定义的方法呗）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerMethodResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exception_handler_methods，MethodFilter实例，表示一个过滤条件（此处定义的条件是方法上是否存在@ExceptionHandler注解）</span></span><br><span class="line">    <span class="comment">/*public static final ReflectionUtils.MethodFilter EXCEPTION_HANDLER_METHODS = method -&gt;</span></span><br><span class="line"><span class="comment">            AnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReflectionUtils.<span class="type">MethodFilter</span> <span class="variable">EXCEPTION_HANDLER_METHODS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectionUtils</span>.MethodFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储异常类和处理这些异常的方法之间的映射关系（ConcurrentReferenceHashMap线程安全，允许高效的并发访问）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;, Method&gt; mappedMethods = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handlerType</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExceptionHandlerMethodResolver</span><span class="params">(Class&lt;?&gt; handlerType)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MethodIntrospector.selectMethods：筛选出handlerType处理器类中所有被@ExceptionHandler注解标记的方法，EXCEPTION_HANDLER_METHODS是一个过滤条件，充当参数</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) &#123;</span><br><span class="line">            <span class="comment">// 对于找到的每一个方法，进一步调用detectExceptionMappings来确定此方法可以处理哪些类型的异常（就是获取注解上指定的异常信息，例如@ExceptionHandler(RuntimeException.class)）</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; exceptionType : detectExceptionMappings(method)) &#123;</span><br><span class="line">                <span class="comment">// 将每个异常类型和对应的处理方法对象添加到mappedMethods映射表中</span></span><br><span class="line">                <span class="built_in">this</span>.mappedMethods.put(exceptionType, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解上指定的异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;&gt; detectExceptionMappings(Method method) &#123;</span><br><span class="line">        <span class="comment">// 查找method上的@ExceptionHandler注解</span></span><br><span class="line">        <span class="type">ExceptionHandler</span> <span class="variable">ann</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class);</span><br><span class="line">        <span class="comment">// 如果没有@ExceptionHandler注解，抛出异常</span></span><br><span class="line">        Assert.state(ann != <span class="literal">null</span>, <span class="string">&quot;No ExceptionHandler annotation&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回注解中指定的异常类型数组</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(ann.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;, Method&gt; getMappedMethods() &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasExceptionMappings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">this</span>.mappedMethods.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回处理异常的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">resolveMethod</span><span class="params">(Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先尝试直接根据异常的类型找到处理方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> resolveMethodByExceptionType(exception.getClass());</span><br><span class="line">        <span class="comment">// 如果没有找到处理方法（method == null），则检查异常是否有原因异常(cause)</span></span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> exception.getCause();</span><br><span class="line">            <span class="comment">// 如果有，尝试根据原因异常的类型找到处理方法</span></span><br><span class="line">            <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                method = resolveMethodByExceptionType(cause.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回找到的方法或null</span></span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过异常类型在映射表中检索对应的处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exceptionClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Method <span class="title function_">resolveMethodByExceptionType</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedMethods.get(exceptionClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-涉及的两个工具类"><a href="#2-1-涉及的两个工具类" class="headerlink" title="2.1 涉及的两个工具类"></a>2.1 涉及的两个工具类</h3><p><code>MethodIntrospector.selectMethods()</code></p>
<p>两个参数：</p>
<ol>
<li><code>Class&lt;?&gt;</code> 要进行方法选择的目标类</li>
<li><code>ReflectionUtils.MethodFilter</code> 方法过滤器，用于定义哪些方法符合选择的条件</li>
</ol>
<p>返回值：符合条件的方法对象列表</p>
<p>（又是两个工具类）</p>
<h2 id="3-ControllerAdviceBean"><a href="#3-ControllerAdviceBean" class="headerlink" title="3. ControllerAdviceBean"></a>3. ControllerAdviceBean</h2><p>包装类，用于封装和管理带有 <code>@ControllerAdvice</code>注解的 <code>bean</code></p>
<p>核心只有这个方法，返回所有 <code>ControllerAdviceBean</code>实例的列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有被<span class="doctag">@ControllerAdvice</span>注解标注的bean，以集合的形式，ControllerAdviceBean即本类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 应用上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ControllerAdviceBean&gt; <span class="title function_">findAnnotatedBeans</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过工具方法获取应用上下文及其所有bean</span></span><br><span class="line">    Map&lt;String, Object&gt; beanMap = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, Object.class);</span><br><span class="line">    <span class="keyword">return</span> beanMap.entrySet().stream()</span><br><span class="line">            <span class="comment">// 过滤处具有@ControllerAdvice注解的bean</span></span><br><span class="line">            .filter(entry -&gt; hasControllerAdvice(entry.getValue()))</span><br><span class="line">            <span class="comment">// 将符合条件的bean封装进ControllerAdviceBean实例中</span></span><br><span class="line">            .map(entry -&gt; <span class="keyword">new</span> <span class="title class_">ControllerAdviceBean</span>(entry.getKey(), entry.getValue()))</span><br><span class="line">            <span class="comment">// 返回一个包含所有符合条件的ControllerAdviceBean实例的列表</span></span><br><span class="line">            .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ExceptionHandlerExceptionResolver"><a href="#4-ExceptionHandlerExceptionResolver" class="headerlink" title="4. ExceptionHandlerExceptionResolver"></a>4. ExceptionHandlerExceptionResolver</h2><p><strong>全局异常处理的核心类</strong></p>
<p>主要作用是解析和管理所有全局异常处理器中的异常处理方法，将异常处理方法融入Spring MVC对控制器方法的处理当中。</p>
<p>主要分为两部分：</p>
<p>一部分是对该核心类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 检查类型转换服务已被设置</span></span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.conversionService, <span class="string">&quot;conversionService can not null&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化异常处理器缓存</span></span><br><span class="line">    initExceptionHandlerAdviceCache();</span><br><span class="line">    <span class="comment">// 设置参数解析器和返回值处理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        <span class="built_in">this</span>.argumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        <span class="built_in">this</span>.argumentResolvers.addResolver(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.addReturnValueHandler(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一部分是解析和管理异常处理方法，将其融入Spring MVC对控制器方法的处理当中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过getExceptionHandlerMethod方法获取封装了处理该异常方法的集成点对象</span></span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">exceptionHandlerMethod</span> <span class="operator">=</span> getExceptionHandlerMethod(ex);</span><br><span class="line">    <span class="keyword">if</span> (exceptionHandlerMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储模型和视图信息</span></span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">    <span class="comment">// 将处理异常的方法移交给集成点对象的invokeAndHandle执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ex.getCause();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(cause)) &#123;</span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(request, response, mavContainer, cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(request, response, mavContainer, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;exceptionHandlerMethod.invokeAndHandle fail&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查请求是否已被处理（是否要生成视图）</span></span><br><span class="line">    <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未被处理的话，返回ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mav.setStatus(mavContainer.getStatus());</span><br><span class="line">    mav.setModel(mavContainer.getModel());</span><br><span class="line">    mav.setView(mavContainer.getView());</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-InvocableHandlerMethod参数处理"><a href="#5-InvocableHandlerMethod参数处理" class="headerlink" title="5. InvocableHandlerMethod参数处理"></a>5. InvocableHandlerMethod参数处理</h2><p>之前的 <code>invokeAndHandle</code>方法并未考虑手动传参的情况，参数解析器会无法处理异常处理方法的参数，现在加上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">getMethodArgumentValues</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                             ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                             Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Assert.notNull(argumentResolver, <span class="string">&quot;HandlerMethodArgumentResolver can not null&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 获取方法参数的值列表</span></span><br><span class="line">    List&lt;MethodParameter&gt; parameters = <span class="built_in">this</span>.getParameters();</span><br><span class="line">    List&lt;Object&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parameters.size());</span><br><span class="line">    <span class="comment">// 2. 遍历方法的参数列表，逐个调用参数解析器来解析参数，并将解析结果添加到参数值列表中</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : parameters) &#123;</span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">        <span class="comment">/////////////////////////</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> findProvidedArgument(parameter, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(arg)) &#123;</span><br><span class="line">            args.add(arg);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/////////////////////////</span></span><br><span class="line">        args.add(argumentResolver.resolveArgument(parameter, request, response, mavContainer, conversionService));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 返回解析好的参数值列表</span></span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">findProvidedArgument</span><span class="params">(MethodParameter parameter, Object... providedArgs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(providedArgs)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object providedArg : providedArgs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameter.getParameterType().isInstance(providedArg)) &#123;</span><br><span class="line">                <span class="keyword">return</span> providedArg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////</span></span><br></pre></td></tr></table></figure>

<h2 id="6-融入DispatcherServlet"><a href="#6-融入DispatcherServlet" class="headerlink" title="6. 融入DispatcherServlet"></a>6. 融入DispatcherServlet</h2><ol>
<li>定义变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Collection&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>init</code>中完成初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.handlerExceptionResolvers =</span><br><span class="line">                <span class="built_in">this</span>.applicationContext.getBeansOfType(HandlerExceptionResolver.class).values();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>完成 <code>processHandlerException</code>中的处理逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                             Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(<span class="built_in">this</span>.handlerExceptionResolvers)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="built_in">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> resolver.resolveException(request, response, ex);</span><br><span class="line">        <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> exMv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未找到对应的异常处理器，就继续抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>processDispatchResult</code>处理分发结果方法中，加上对异常的判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   ModelAndView mv, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line">    <span class="comment">// 检查是否有异常发生，如果有，调用processHandlerException方法处理异常，该方法响应错误json数据或者返回一个错误页面的ModelAndView</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(ex)) &#123;</span><br><span class="line">        <span class="comment">//error ModelAndView</span></span><br><span class="line">        mv = processHandlerException(request, response, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查ModelAndView是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(mv)) &#123;</span><br><span class="line">        <span class="comment">// 如果不为null，则调用render方法渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果为null，记录日志，无视图被渲染</span></span><br><span class="line">    logger.info(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论控制器方法返回的是响应数据还是视图，该方法最终都会被执行到，然后进行统一的异常处理。</p>
<ol start="5">
<li><code>doDispatch()</code>方法中的两层 <code>try-catch</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 用于记录过程中发生的任何异常</span></span><br><span class="line">    <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用于保存处理请求的处理器链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取与请求匹配的处理器链</span></span><br><span class="line">            executionChain = <span class="built_in">this</span>.handlerMapping.getHandler(request);</span><br><span class="line">            <span class="comment">// 执行处理器链中的预处理操作。如果预处理返回false，则直接返回不继续执行后续操作</span></span><br><span class="line">            <span class="keyword">if</span> (!executionChain.applyPreHandle(request, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际调用处理器，实例化集成点对象的地方，实际处理了一个HTTP请求，返回ModelAndView对象</span></span><br><span class="line">            <span class="comment">// （这里集成了之前所有的参数解析器，返回值处理器，Handler执行器，集成点对象(从拦截器链中获取的)）</span></span><br><span class="line">            mv = handlerAdapter.handle(request, response, executionChain.getHandler());</span><br><span class="line">            <span class="comment">// 执行拦截器链后处理操作</span></span><br><span class="line">            executionChain.applyPostHandle(request, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果内部处理器不能解决异常，或者由于某种原因重新抛出了异常，</span></span><br><span class="line"><span class="comment">             * 那么这个异常就会被外部 try-catch 块捕获并再次抛出，</span></span><br><span class="line"><span class="comment">             * 此时它将逃离 Spring 的处理流程，交由更上层的异常处理机制处理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dispatchException = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理分发结果，包括视图渲染和异常处理</span></span><br><span class="line">        processDispatchResult(request, response, mv, dispatchException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dispatchException = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 执行处理链的完成后处理方法，无论请求处理过程是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(executionChain)) &#123;</span><br><span class="line">            executionChain.triggerAfterCompletion(request, response, dispatchException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部的 <code>try-catch</code>确保了异常管理的健壮性和灵活性，不仅保证了在Spring MVC内部有充分的机会处理异常，也保证了异常不会丢失，继续向上抛出，传递到更广泛的上下文中去处理。</p>
<p>如果没有外部的 <code>try-catch</code></p>
<ul>
<li>一方面会导致异常丢失，导致异常信息不完整，使得开发者难以理解和追踪错误发生的原因和位置</li>
<li>另一方面，对于用户体验来说，用户无法看到更准确的错误信息，影响体验</li>
</ul>
<h2 id="7-异常链"><a href="#7-异常链" class="headerlink" title="7. 异常链"></a>7. 异常链</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1  概述"></a>7.1  概述</h3><p>异常链，用来描述一个异常是如何由另一个异常引起的。在处理复杂系统或多层架构的错误时，了解错误发生的完整路径和原因非常关键。异常链允许开发者将一个异常封装到另一个异常中，从而保持关于错误原因的详细信息不被丢失，同时也能添加更多的上下文信息或者将异常转换为更适合当前层级处理的形式。</p>
<h3 id="7-2-作用与目的"><a href="#7-2-作用与目的" class="headerlink" title="7.2 作用与目的"></a>7.2 作用与目的</h3><p>异常链的主要目的是保留错误处理过程中的完整信息，使得调试和错误诊断更加高效。这样做的好处包括：</p>
<ol>
<li><strong>保持错误上下文</strong>：在将异常从一个系统层次传递到另一个系统层次时，保持原始异常的信息，如具体的错误代码、失败的操作和其他诊断信息。</li>
<li><strong>帮助诊断问题</strong>：底层异常常常包含了引起错误的直接原因，而顶层异常可能只说明了错误的一般性质或上下文。所以需要在异常从一个系统层次传递到另一个系统层次时，保持原始异常的信息，允许开发者或最终用户获得更详细的错误报告，包含原始错误的完整链条，而不仅仅是最后一环。</li>
</ol>
<h3 id="7-3-实现"><a href="#7-3-实现" class="headerlink" title="7.3 实现"></a>7.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行某些可能失败的操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowLevelException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HighLevelException</span>(<span class="string">&quot;Failed due to underlying error&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这么通过在异常的构造器中传递另一个异常对象来实现的。</p>
<h3 id="7-4-检索异常链"><a href="#7-4-检索异常链" class="headerlink" title="7.4 检索异常链"></a>7.4 检索异常链</h3><p>调用异常对象的 <code>getCause()</code>方法可以访问这个链中的前一个异常，可以递归地完成，直到到达链中的第一个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 高级别的操作，可能抛出封装了其他异常的高级别异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (HighLevelException e) &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">    <span class="keyword">while</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(cause.getMessage());</span><br><span class="line">        cause = cause.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-原因异常"><a href="#7-5-原因异常" class="headerlink" title="7.5 原因异常"></a>7.5 原因异常</h3><p>原因异常（cause exception）通常是指在异常链中引发当前异常的上一个异常。</p>
<h1 id="核心配置类"><a href="#核心配置类" class="headerlink" title="核心配置类"></a>核心配置类</h1><h2 id="1-组成组件-2"><a href="#1-组成组件-2" class="headerlink" title="1. 组成组件"></a>1. 组成组件</h2><p><code>WebMvcConfigurer</code>接口</p>
<p>定义了一系列用来自定义和配置Spring MVC的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 参数解析器的扩展点</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值解析器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器暴露对外的扩展点</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据转换格式化暴露对外的扩展点</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图的扩展点</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addDefaultViews</span><span class="params">(List&lt;View&gt; views)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图解析器的扩展点</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addViewResolvers</span><span class="params">(List&lt;ViewResolver&gt; viewResolvers)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebMvcConfigurerComposite</code>类</p>
<p> 实现了 <code>WebMvcConfigurer</code>接口，集中管理多个 <code>WebMvcConfigurer</code>配置实例，使其可以整合在一个单一的组合体上进行配置，保持了代码的简洁和模块化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfigurerComposite</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有配置器对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WebMvcConfigurer&gt; delegates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">        delegates.forEach(configurer -&gt; configurer.addArgumentResolvers(argumentResolvers));</span><br><span class="line">        <span class="comment">/*for (WebMvcConfigurer configurer : delegates) &#123;</span></span><br><span class="line"><span class="comment">            configurer.addArgumentResolvers(argumentResolvers);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebMvcConfigurationSupport</code></p>
<p>集中配置了Spring MVC所需的组件，将其注入Spring容器当中，从而提供了 <code>DispatchServlet</code>所有需要使用到的组件，并提供了一系列钩子，允许开发者自定义和扩展Spring MVC的行为。</p>
<p>提供的组件：</p>
<ol>
<li>构建数据转换服务</li>
<li>构建拦截器列表</li>
<li>处理Http请求映射核心组件</li>
<li><code>RequestMapping</code>处理器适配器，内部实例化了集成点对象</li>
<li>获取返回值处理器列表</li>
<li>获取参数解析器列表</li>
<li>定义全局异常处理器</li>
<li>视图解析</li>
</ol>
<p><code>DelegatingWebMvcConfiguration</code></p>
<p>集中管理多个 <code>WebMvcConfigurer</code>接口的实现，允许多个独立的配置器一起工作，合并它们的配置，并通过覆盖父类中的方法将这些配置应用到Spring MVC中，以此提供一个灵活且强大的方式来自定义Spring MVC的行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储和执行所有注册的WebMvcConfigurer实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许Spring自动查找并注入List&lt;WebMvcConfigurer&gt;类型的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configurers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span> <span class="comment">// 表示依赖是可选的，如果没有找bean，不会抛异常，允许该方法不执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        configurers.addFormatters(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        configurers.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> &#123;</span><br><span class="line">        configurers.addReturnValueHandlers(returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">        configurers.addArgumentResolvers(argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addDefaultViews</span><span class="params">(List&lt;View&gt; views)</span> &#123;</span><br><span class="line">        configurers.addDefaultViews(views);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addViewResolvers</span><span class="params">(List&lt;ViewResolver&gt; viewResolvers)</span> &#123;</span><br><span class="line">        configurers.addViewResolvers(viewResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-组件间关系"><a href="#2-组件间关系" class="headerlink" title="2. 组件间关系"></a>2. 组件间关系</h2><p><code>WebMvcConfigurer</code> 是一个接口，定义了一系列可以用来自定义和配置 Spring MVC的方法。</p>
<p><code>WebMvcConfigurerComposite</code> 实现了 <code>WebMvcConfigurer</code> 接口，组织多个 <code>WebMvcConfigurer</code> 实现。集中管理多个配置，并将所有配置器的配置聚合到一个统一的配置点。</p>
<p><code>WebMvcConfigurationSupport</code> 类提供了 Spring MVC 配置的基础设施支持，定义了一系列可以被子类覆盖的保护方法和创建必要 Spring MVC 组件的 <code>@Bean</code> 方法。</p>
<p><code>DelegatingWebMvcConfiguration</code> 继承自 <code>WebMvcConfigurationSupport</code>，并使用 <code>WebMvcConfigurerComposite</code> 来整合多个 <code>WebMvcConfigurer</code> 实现。它主要的职责是将接收到的所有 <code>WebMvcConfigurer</code> 实现的配置聚集到一处，并通过覆盖父类（<code>WebMvcConfigurationSupport</code>）中的方法将这些配置应用到 Spring MVC 中。</p>
<p><strong>集成和扩展</strong>：<code>WebMvcConfigurerComposite</code> 将多个 <code>WebMvcConfigurer</code> 实例的功能集成到一个配置点。<code>DelegatingWebMvcConfiguration</code> 则使用这个组合，并将其作为桥梁通过 <code>WebMvcConfigurationSupport</code> 提供的基础设施将配置应用到 Spring MVC。</p>
<p><strong>继承链和实现</strong>：<code>DelegatingWebMvcConfiguration</code> 是 <code>WebMvcConfigurationSupport</code> 的一个具体实现，它扩展了基础的 MVC 配置支持，并通过组合 <code>WebMvcConfigurerComposite</code>实现了对多个配置的管理和应用。</p>
<h2 id="3-EnableWebMvc"><a href="#3-EnableWebMvc" class="headerlink" title="3. @EnableWebMvc"></a>3. @EnableWebMvc</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DelegatingWebMvcConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Import(DelegatingWebMvcConfiguration.class)就相当于向Spring容器中注入了DelegatingWebMvcConfiguration实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当在Spring配置上使用@EnableWebMvc注解时，实际是向Spring容器中注入了DelegatingWebMvcConfiguration，</span></span><br><span class="line"><span class="comment"> *   即注入了Spring MVC所必要的基础设施，轻松地在Spring应用中启用和自定义了全面的Spring MVC支持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与SpringBoot集成（一）"><a href="#与SpringBoot集成（一）" class="headerlink" title="与SpringBoot集成（一）"></a>与SpringBoot集成（一）</h1><p><img src="https://camo.githubusercontent.com/5951cc2a3c96b8279095e4c371bb88cb5d2921f72fc8299343680349b396680f/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f31376330346630636565666234303864383338343066383538663965313734317e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="image"></p>
<p><code>GenericWebApplicationContext</code>集成了Web环境</p>
<p><code>ServletWebServerApplicaationContext</code>集成了内嵌的Servlet容器</p>
<h2 id="Spring-MVC中"><a href="#Spring-MVC中" class="headerlink" title="Spring MVC中"></a>Spring MVC中</h2><p><code>WebApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展了ApplicationContext，专门用于Web环境</span></span><br><span class="line"><span class="comment"> * 基于IOC容器ApplicationContext，提供了获取ServletContext的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root_web_application_context_attribute 存储在Web应用的ServletContext中，用于标识跟Web应用程序上下文的属性名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span> <span class="operator">=</span> WebApplicationContext.class.getName() + <span class="string">&quot;.ROOT&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与Web容器的交互入口点，用于获取Web应用的各种配置和上下文信息</span></span><br><span class="line">    ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurableWebApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要提供配置ApplicationContext的功能</span></span><br><span class="line"><span class="comment"> * WebApplicationContext接口主要用于获取Web应用程序上下文，包括获取ServletContext、获取Web应用程序的配置信息等</span></span><br><span class="line"><span class="comment"> * ConfigurableApplicationContext接口提供了配置ApplicationContext的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableWebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">WebApplicationContext</span>, ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许显式设置ServletContext，用于设置当前Application的ServletContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setServletContext</span><span class="params">(ServletContext servletContext)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GenericWebApplicationContext</code>（继承了 <code>Ioc</code>中 <code>ApplicationContext</code>的实现类，拓展为一个通用的 <code>web</code>应用上下文）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个通用的Web应用上下文，提供了与Servlet容器集成的能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericWebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">GenericApplicationContext</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConfigurableWebApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServletContext的实例，用于存储与Servlet容器相关的信息，提供了与Servlet容器交互的能力</span></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，用于创建一个与给定的ServletContext相关联的Web应用上下文。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext Servlet上下文，提供与Servlet容器交互的能力。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletContext = servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造函数，创建一个不与任何ServletContext关联的Web应用上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置与当前Web应用上下文关联的ServletContext。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext 要设置的Servlet上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServletContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletContext = servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前Web应用上下文关联的ServletContext。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 关联的Servlet上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.servletContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot中"><a href="#Spring-Boot中" class="headerlink" title="Spring Boot中"></a>Spring Boot中</h2><p><code>ServletWebServerApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 又是一个应用上下文</span></span><br><span class="line"><span class="comment"> * 主要目的在Spring Boot应用程序启动时创建和管理Web服务器，并将应用上下文与Web服务器集成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">GenericWebApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">WebServerApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义WebServer，存储创建的Web服务器实例。这是SpringBoot中的类，有多个实现：Tomcat，jetty等等</span></span><br><span class="line">    <span class="keyword">private</span> WebServer webServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * try-catch整个容器的refresh过程，一旦出现任何异常，都需要关闭掉WebServer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.refresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">            <span class="keyword">if</span> (webServer != <span class="literal">null</span>) &#123;</span><br><span class="line">                webServer.stop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onRefresh是IOC容器提供的方法，允许用户在容器启动过程中做一些事情，这里我们就来创建和启动Web服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onRefresh();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.webServer = createWebServer();</span><br><span class="line">            <span class="built_in">this</span>.webServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ServletWebServerFactory工厂创建Web服务器</span></span><br><span class="line">    <span class="keyword">private</span> WebServer <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getBeanFactory().getBean(ServletWebServerFactory.class);</span><br><span class="line">        <span class="keyword">return</span> factory.getWebServer(<span class="built_in">this</span>::selfInitialize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServletContextInitializer 在Web容器启动完成后会回调此方法，下篇我们就会用到这个类，</span></span><br><span class="line">    <span class="comment">//  向ServletContext中添加DispatchServlet，即初始化Servlet上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selfInitialize</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        prepareWebApplicationContext(servletContext);</span><br><span class="line">        Map&lt;String, ServletContextInitializer&gt; beanMaps = getBeanFactory().getBeansOfType(ServletContextInitializer.class);</span><br><span class="line">        <span class="keyword">for</span> (ServletContextInitializer bean : beanMaps.values()) &#123;</span><br><span class="line">            bean.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Servlet上下文中存储ApplicationContext，并保存对ServletContext的引用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>);</span><br><span class="line">        setServletContext(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DispatcherServletRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个用于注册DispatcherServlet的ServletRegistrationBean扩展，</span></span><br><span class="line"><span class="comment"> * 同时实现了DispatcherServletPath接口，以提供Servlet的路径配置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">ServletRegistrationBean</span>&lt;DispatcherServlet&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">DispatcherServletPath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path; <span class="comment">// Servlet的注册路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数用于创建一个DispatcherServlet的注册bean，并配置其URL映射。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servlet 要注册的DispatcherServlet实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path Servlet的注册路径，不能为空。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet servlet, String path)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(servlet);</span><br><span class="line">        Assert.notNull(path, <span class="string">&quot;Path must not be null&quot;</span>); <span class="comment">// 确保路径不为空</span></span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">        <span class="built_in">super</span>.addUrlMappings(getServletUrlMapping()); <span class="comment">// 添加URL映射</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Servlet的注册路径。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回Servlet的注册路径。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与SpringBoot集成（二）"><a href="#与SpringBoot集成（二）" class="headerlink" title="与SpringBoot集成（二）"></a>与SpringBoot集成（二）</h1><p>引入 <code>Tomcat</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ServletWebServerFactoryAutoConfiguration</code></p>
<p>创建 <code>TomcatServletWebServerFactory</code>，根据应用程序的环境和依赖情况自动配置 <code>Tomcat</code>作为嵌入式 <code>Servlet</code>容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring Boot自动配置类，用于根据应用程序的环境和依赖情况自动配置Tomcat作为嵌入式Servlet容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 表示该类为Spring配置类，集成了@Component注解说明该类会被自动注入，此类可以使用@Bean注解来初始化定义bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 条件注解，仅当类路径上存在ServletRequest.class时，当前配置类才会被考虑</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="comment">// 启用对ServerProperties类中定义的配置属性的支持，这使得Spring Boot的配置文件（如application.properties或application.yml）中的相关属性可以绑定到ServerProperties类的实例上</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 表示该方法将返回一个bean，由Spring容器管理</span></span><br><span class="line">    <span class="comment">// 条件注解，进一步限定了Tomcat及其他相关类存在于类路径上时，这个bean才会被创建</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)</span></span><br><span class="line">    <span class="comment">// 只有当ServletWebServerFactory类型的bean不存在时，此方法配置的bean才会被创建</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ServerProperties serverProperties, // 服务器配置</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers, // 连接器定制器</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers, // 上下文定制器</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> &#123; <span class="comment">// 协议处理器定制器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个TomcatServletWebServerFactory实例</span></span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将从Spring容器中获取的连接器、上下文和协议处理器定制器添加到工厂配置中</span></span><br><span class="line">        factory.getTomcatConnectorCustomizers() <span class="comment">// 连接器定制器</span></span><br><span class="line">                .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">        factory.getTomcatContextCustomizers() <span class="comment">// 上下文定制器</span></span><br><span class="line">                .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">        factory.getTomcatProtocolHandlerCustomizers() <span class="comment">// 协议处理器定制器</span></span><br><span class="line">                .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用PropertyMapper工具类来简化属性之间的映射。此处，它确保仅当属性非空时才应用映射</span></span><br><span class="line">        <span class="type">PropertyMapper</span> <span class="variable">map</span> <span class="operator">=</span> PropertyMapper.get().alwaysApplyingWhenNonNull();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map.from(...).to(...)语法用于从ServerProperties对象映射属性到TomcatServletWebServerFactory实例</span></span><br><span class="line">        map.from(serverProperties::getPort).to(factory::setPort);</span><br><span class="line">        map.from(serverProperties::getAddress).to(factory::setAddress);</span><br><span class="line">        map.from(serverProperties.getServlet()::getContextPath).to(factory::setContextPath);</span><br><span class="line">        map.from(serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName);</span><br><span class="line">        map.from(serverProperties.getServlet()::isRegisterDefaultServlet).to(factory::setRegisterDefaultServlet);</span><br><span class="line">        map.from(serverProperties.getServlet()::getSession).to(factory::setSession);</span><br><span class="line">        map.from(serverProperties::getSsl).to(factory::setSsl);</span><br><span class="line">        map.from(serverProperties.getServlet()::getJsp).to(factory::setJsp);</span><br><span class="line">        map.from(serverProperties.getShutdown()).to(factory::setShutdown);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回配置好的TomcatServletWebServerFactory实例</span></span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DispatcherServletAutoConfiguration</code></p>
<p>创建 <code>DispatcherServlet</code>、<code>DispatcherServletRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring Boot自动配置类，用于在Spring MVC应用中自动配置DispatcherServlet</span></span><br><span class="line"><span class="comment"> * （即创建、配置和注册DispatcherServlet，使得Spring Boot能够根据条件自动配置和启用Spring MVC的核心控制器）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 标记该类为配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这个类的加载和注册取决于 DispatcherServlet.class 是否在类路径上可用，确保只有在使用Spring MVC时才应用这个配置</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="comment">// 启用 WebMvcProperties 类的配置属性支持，允许从外部配置源（如application.properties或application.yml）加载并绑定配置属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义默认的DispatcherServlet bean名称，这个名称将用于在Spring容器中注册bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;smartMvcDispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建DispatcherServlet实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 定义一个方法，该方法返回一个新的 DispatcherServlet 实例</span></span><br><span class="line">    <span class="comment">// 仅在不存在 DispatcherServlet 类型的Bean时，才创建和注册新的 DispatcherServlet 实例。这确保了如果已经有其他配置提供了 DispatcherServlet，这个自动配置不会重复添加</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(value = DispatcherServlet.class)</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册DispatcherServlet到Servlet容器，并配置其URL映射和其他相关设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dispatcherServlet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webMvcProperties 路径信息（从WebMvcProperties中获取）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 返回类型为自定义的 SmartMvcDispatcherServletRegistrationBean</span></span><br><span class="line">    <span class="comment">// 该bean的创建依赖于 DispatcherServlet 类型的Bean的存在</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(value = DispatcherServlet.class)</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistration</span><span class="params">(</span></span><br><span class="line"><span class="params">            DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用SmartMvcDispatcherServletRegistrationBean来注册DispatcherServlet，并通过传递的 WebMvcProperties 来设置Servlet的路径、名称和启动优先级</span></span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet,</span><br><span class="line">                webMvcProperties.getServlet().getPath());</span><br><span class="line">        registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">        registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动化配置的入口类 <code>WebMvcAutoConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责配置Spring MVC的许多默认行为，通过一系列的条件检查和配置导入，提供了一个便捷的方式自动配置Spring MVC，同时也保留了一定的扩展性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 声明配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 该配置类只有在容器中不存在WebMvcConfigurationSupport类型的Bean时才会生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="comment">// 自动注入DispatcherServlet自动配置类和配置内嵌Servlet容器类</span></span><br><span class="line"><span class="meta">@Import(&#123;DispatcherServletAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Spring MVC默认组件</span></span><br><span class="line">    <span class="meta">@EnableWebMvc</span></span><br><span class="line">    <span class="comment">// 使得WebMvcProperties类中定义的属性与Spring Boot的外部配置（如application.properties或application.yml文件）相绑定，允许开发者通过这些外部配置文件来设置Spring MVC的属性</span></span><br><span class="line">    <span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spring.factories</code></p>
<p><code>spring.factories</code>文件，用于在Spring Boot应用启动时自动发现并应用一系列预定义的配置类，由各种Spring Boot的starter包提供。</p>
<p>由键值对组成</p>
<ul>
<li>键通常表示一个接口，用于查找特定类型的组件</li>
<li>值是与键相关联的具体实现类的全类名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.springframework.boot.configurure.WebMvcAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>在这里就是通过识别 <code>EnableAutoConfiguration</code>注解来自动实现 <code>WebMvcAutoConfiguration</code>配置类</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/img/spring-logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/25/Spring/my-mini-springboot/" title="Spring Boot原理解析"><img class="cover" src="/img/spring-boot-logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot原理解析</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析"><img class="cover" src="/img/spring-logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mini-spring原理解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/15/Spring/Spring/" title="Core technologies"><img class="cover" src="/img/spring-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-15</div><div class="title">Core technologies</div></div></a></div><div><a href="/2024/05/25/Spring/my-mini-springboot/" title="Spring Boot原理解析"><img class="cover" src="/img/spring-boot-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-25</div><div class="title">Spring Boot原理解析</div></div></a></div><div><a href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析"><img class="cover" src="/img/spring-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="title">mini-spring原理解析</div></div></a></div><div><a href="/2024/04/15/Spring/SpringMVC/" title="SpringMVC"><img class="cover" src="/img/spring-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-15</div><div class="title">SpringMVC</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://lovely-picture.oss-cn-beijing.aliyuncs.com/star_rail/match7th001.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Voyager001</div><div class="author-info__description">人闲桂花落，夜静春山空</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hezhengdong" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/fortunatexyz@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%A8%80"><span class="toc-text">导言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-text">整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8"><span class="toc-text">1. 处理器映射器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">2. 处理器适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">3. 视图解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-DispatcherServlet"><span class="toc-text">4. DispatcherServlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">5. 全局异常处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">6. 核心配置类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. 代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. 责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">3. 策略模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-text">处理器映射器-建立映射关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E6%88%90%E7%BB%84%E4%BB%B6"><span class="toc-text">1. 组成组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E7%B1%BB-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2. 核心类&amp;执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.2 具体步骤&amp;类详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E8%BF%9B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83"><span class="toc-text">2.3 如何集成进上下文环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%A4%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">3. 两个工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%84%8F%E4%B9%89"><span class="toc-text">4. 合并注解的原理及意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB"><span class="toc-text">核心组件和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8E%9F%E7%90%86%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">合并原理的步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-text">1. 核心类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-text">2. 代理模式（静态代理）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%85%B3%E7%B3%BB"><span class="toc-text">2.1 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9B%AE%E7%9A%84"><span class="toc-text">2.2 设计的核心目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">2.3 代理模式特点的体现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-%E8%BF%94%E5%9B%9E%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE%E5%AF%B9%E8%B1%A1"><span class="toc-text">处理器映射器-返回处理器链对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">1. 拦截器执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88preHandle-postHandle-afterCompletion%EF%BC%89%E8%A6%81%E4%BB%A5%E7%89%B9%E5%AE%9A%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">1.1 为什么多个拦截器的三个方法（preHandle, postHandle, afterCompletion）要以特定的顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93-preHandle-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E-false-%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%B7%B3%E8%BF%87%E6%89%80%E6%9C%89-postHandle-%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">1.2 为什么当 preHandle 方法返回 false 后，会跳过所有 postHandle 方法的执行？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-getHandler-%E6%96%B9%E6%B3%95"><span class="toc-text">2. getHandler()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Handler"><span class="toc-text">3. Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Spring-MVC%E4%B8%AD%E7%9A%84Handler"><span class="toc-text">3.1 Spring MVC中的Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Handler%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-text">3.2 Handler的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Handler%E4%B8%8E%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">3.3 Handler与其他组件的交互</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">参数解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E6%88%90%E7%BB%84%E4%BB%B6-1"><span class="toc-text">1. 组成组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">2. 前后端对接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.1 过程详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%87%8D%E8%A6%81%E7%9A%84%E7%82%B9"><span class="toc-text">2.2 重要的点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">返回值处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A1%A5%E5%85%85"><span class="toc-text">2. 补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-text">Handler执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-InvocableHandlerMethod"><span class="toc-text">1. InvocableHandlerMethod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ParameterNameDiscoverer"><span class="toc-text">2. ParameterNameDiscoverer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MethodParameter"><span class="toc-text">3. MethodParameter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF"><span class="toc-text">3.1 表示方法参数信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">3.2 表示方法返回值类型信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">处理器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HandlerAdapter"><span class="toc-text">1. HandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RequestMappingHandlerAdapter"><span class="toc-text">2. RequestMappingHandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ModelAndView-ModelAndViewContainer"><span class="toc-text">3. ModelAndView&amp;ModelAndViewContainer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-ModelAndView"><span class="toc-text">3.1 ModelAndView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ModelAndViewContainer"><span class="toc-text">3.2 ModelAndViewContainer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">视图的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RedirectView"><span class="toc-text">1. RedirectView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-InternalResourceView"><span class="toc-text">2. InternalResourceView</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">视图解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ViewResolver%E6%8E%A5%E5%8F%A3"><span class="toc-text">1. ViewResolver接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AbstractCachingViewResolver"><span class="toc-text">2. AbstractCachingViewResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UrlBasedViewResolver"><span class="toc-text">3. UrlBasedViewResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-InternalResourceViewResolver"><span class="toc-text">4. InternalResourceViewResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8B%BC%E6%8E%A5%E5%89%8D%E5%90%8E%E7%BC%80"><span class="toc-text">5. 拼接前后缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-RequestContextHolder%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">6. RequestContextHolder工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ContentNegotiatingViewResolver"><span class="toc-text">7. ContentNegotiatingViewResolver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DispatcherServlet"><span class="toc-text">DispatcherServlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">全局异常处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ExceptionHandlerMethodResolver"><span class="toc-text">2. ExceptionHandlerMethodResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B6%89%E5%8F%8A%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">2.1 涉及的两个工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ControllerAdviceBean"><span class="toc-text">3. ControllerAdviceBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ExceptionHandlerExceptionResolver"><span class="toc-text">4. ExceptionHandlerExceptionResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-InvocableHandlerMethod%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">5. InvocableHandlerMethod参数处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%9E%8D%E5%85%A5DispatcherServlet"><span class="toc-text">6. 融入DispatcherServlet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-text">7. 异常链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1  概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%9B%AE%E7%9A%84"><span class="toc-text">7.2 作用与目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.3 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%A3%80%E7%B4%A2%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-text">7.4 检索异常链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%8E%9F%E5%9B%A0%E5%BC%82%E5%B8%B8"><span class="toc-text">7.5 原因异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">核心配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E6%88%90%E7%BB%84%E4%BB%B6-2"><span class="toc-text">1. 组成组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%84%E4%BB%B6%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-text">2. 组件间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EnableWebMvc"><span class="toc-text">3. @EnableWebMvc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8ESpringBoot%E9%9B%86%E6%88%90%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">与SpringBoot集成（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E4%B8%AD"><span class="toc-text">Spring MVC中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot%E4%B8%AD"><span class="toc-text">Spring Boot中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8ESpringBoot%E9%9B%86%E6%88%90%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">与SpringBoot集成（二）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/13/Redis/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="Redis-实战篇"><img src="/img/redis-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis-实战篇"/></a><div class="content"><a class="title" href="/2024/06/13/Redis/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="Redis-实战篇">Redis-实战篇</a><time datetime="2024-06-13T14:07:25.000Z" title="发表于 2024-06-13 22:07:25">2024-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/25/Spring/my-mini-springboot/" title="Spring Boot原理解析"><img src="/img/spring-boot-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot原理解析"/></a><div class="content"><a class="title" href="/2024/05/25/Spring/my-mini-springboot/" title="Spring Boot原理解析">Spring Boot原理解析</a><time datetime="2024-05-25T06:52:12.000Z" title="发表于 2024-05-25 14:52:12">2024-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/21/Spring/my-mini-springmvc/" title="mini-springmvc原理解析"><img src="/img/spring-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mini-springmvc原理解析"/></a><div class="content"><a class="title" href="/2024/05/21/Spring/my-mini-springmvc/" title="mini-springmvc原理解析">mini-springmvc原理解析</a><time datetime="2024-05-21T11:14:21.000Z" title="发表于 2024-05-21 19:14:21">2024-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析"><img src="/img/spring-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mini-spring原理解析"/></a><div class="content"><a class="title" href="/2024/05/06/Spring/my-mini-spring/" title="mini-spring原理解析">mini-spring原理解析</a><time datetime="2024-05-06T14:52:00.000Z" title="发表于 2024-05-06 22:52:00">2024-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Spring/Spring/" title="Core technologies"><img src="/img/spring-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Core technologies"/></a><div class="content"><a class="title" href="/2024/04/15/Spring/Spring/" title="Core technologies">Core technologies</a><time datetime="2024-04-15T13:46:00.000Z" title="发表于 2024-04-15 21:46:00">2024-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/spring-logo.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By Voyager001</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liNV3Lp0oFQJQNsS',
      clientSecret: '97a505177f725718b7ac115f5558fcda3539965c',
      repo: 'hezhengdong.github.io',
      owner: 'hezhengdong',
      admin: ['hezhengdong'],
      id: 'b4dca9656de0455c56e1881b28fb1160',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>